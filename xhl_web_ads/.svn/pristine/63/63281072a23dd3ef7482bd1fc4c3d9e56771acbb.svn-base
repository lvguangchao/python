#!/usr/bin/env python
# encoding: utf-8

"""
@author: lvguangchao
@email: guangchao.lv@qq.com
@file: ads.py
@time: 2017/11/7 13:58
"""
from eom_common.eomcore.logger import *
from .base import SwxJsonHandler
from decimal import *
import xlrd
from eom_app.orm.tables import AdsInfo, ContractPackInfo, NeedInfo, NeedGroupInfo, AdsContractInfo, \
    GroupNeedMap, NeedSchedule, AdsConfigAnchorWhitelist, AdsConfigAnchorBlacklist, \
    NeedSchedule, TLogWithdrawAnchor, Paltform, BaseUser, AdsNeedPlanInfo, \
    TIdentityPersonal, TaskPlayLog, AdsNeedPlanInfo, AdsOpLog, AdsTask, PlayLogAuto, \
    Adresult, PackageNeedMap, PackageInfo, BasePlatformsGuild

import re
from .helper import randomCode
from sqlalchemy import func, or_, and_, distinct, case
import json, os, base64, datetime, tornado, random, time, zipfile
from  eom_app.orm.JSONEncoder import AlchemyEncoder
from eom_common.eomcore.logger import log
from eom_app.controller.helper.uploadManager import app_upManager
from eom_app.app.configs import app_cfg
from eom_app.controller.helper.identity import app_map
from eom_app.controller.export import export, exportIncome, exportPlayRecord
from xlrd import xldate_as_tuple
from urllib import request
from eom_app.controller.helper.ExcelImportManager import getplaylogDict, getplaylogAutoDict
from urllib.parse import urljoin

cfg = app_cfg()
from decimal import *
from tornado.concurrent import run_on_executor

app_upManager = app_upManager()

app_playlog = getplaylogDict()
app_playlogAuto = getplaylogAutoDict()


####---------------广告---------------------------------
class AdsInfoHander(SwxJsonHandler):
    @tornado.web.authenticated
    def get(self, *args, **kwargs):
        self.render("/ads_manager/ads_info/adsinfo_list.mako")

    @tornado.web.authenticated
    def post(self, *args, **kwargs):
        limit, args = self.get_pages_args()

        sql = "SELECT ads_id,ads_name,ads_materialurl,ads_materialurl_md5,ads_thumbnailurl,ads_contents,logtime,ads_time  from ads_info where 1=1"

        filter = args["filter"]
        name = ""
        if "search" in filter.keys():
            name = filter["search"]
        if name is not None and name != "":
            sql = sql + " and ads_name like '%" + name.strip() + "%'"
        offset = " ORDER BY ads_id DESC LIMIT {},{}".format(limit['page_index'] * 10, limit['per_page'])
        datas = self.db_ads.execute(sql + offset).fetchall()

        lst = list()
        for data in datas:
            ads_id = data[0]
            ads_name = data[1]
            ads_materialurl = data[2]
            ads_materialurl_md5 = data[3]
            ads_thumbnailurl = data[4]
            ads_contents = data[5]
            logtime = data[6].isoformat()
            ads_time = data[7]
            lst.append(
                {"ads_id": ads_id, "ads_name": ads_name, "ads_materialurl": ads_materialurl, "ads_time": ads_time,
                 "ads_materialurl_md5": ads_materialurl_md5, "ads_thumbnailurl": ads_thumbnailurl,
                 "logtime": logtime, "ads_contents": ads_contents})

        count = self.db_ads.execute("select count(*) from({}) as count_data".format(sql)).scalar()
        ret = dict()
        ret['page_index'] = limit['page_index']
        ret['total'] = count
        ret['data'] = lst
        self.write_json(0, data=ret)
        self.db_ads.close()


class adsinfoAddHander(SwxJsonHandler):
    @tornado.web.authenticated
    @tornado.gen.coroutine
    def post(self, *args, **kwargs):
        # file_metas = self.request.files.get("file", None)  # 获取上传视频信息
        file_metas_pic = self.request.files.get("file_pic", None)  # 获取上传图片信息
        task_gen = self.get_argument("task_gen", None)
        ads_contents = self.get_argument("ads_contents", None)
        ads_name = self.get_argument("ads_name", None)
        ads_time = self.get_argument("ads_time", None)
        if not task_gen:
            self.write_json(-1, "系统错误,请重试")
            return

        adsinfo = AdsInfo()
        adsinfo.ads_contents = ads_contents
        adsinfo.ads_name = ads_name
        adsinfo.ads_time = int(ads_time) if ads_time is not None else 0
        try:
            self.db_ads.add(adsinfo)
            self.db_ads.commit()
        except Exception as  e:
            self.db_ads.rollback()
            self.db_ads.close()
            log.e(e)
            self.write_json(500, "添加失败")
            return

        if adsinfo.ads_id is None:
            self.write_json(-1, "系统错误")
            return

        upload = app_upManager.find_task(task_gen).uploadSSH
        remotePath = cfg.file_remotePath + "/" + str(adsinfo.ads_id)  # 文件夹路径

        v_data = self.db_ads.query(AdsInfo).filter(AdsInfo.ads_id == adsinfo.ads_id).first()

        # if file_metas:
        #     for meta in file_metas:  # 循环文件信息
        #         file_name = meta['filename']  # 获取文件的名称
        #         (fn, extension) = os.path.splitext(file_name)
        #         t = int(time.time())
        #         file_name = "{}_{}{}".format(str(adsinfo.ads_id), t, extension)  # 文件名称
        #         yield self.upload_task(upload, meta['body'], remotePath, file_name)
        #         import hashlib  # 计算文件的MD5
        #         md5_obj = hashlib.md5()
        #         md5_obj.update(meta['body'])
        #         hash_code = md5_obj.hexdigest()
        #         md5 = str(hash_code).upper()
        #         v_data.ads_materialurl = file_name
        #         v_data.ads_materialurl_md5 = md5

        if file_metas_pic:
            for meta in file_metas_pic:  # 循环文件信息
                file_name = meta['filename']  # 获取文件的名称
                (fn, extension) = os.path.splitext(file_name)
                t = int(time.time())
                file_name = "{}_{}{}".format(str(adsinfo.ads_id), t, extension)  # 文件名称
                yield self.upload_task(upload, meta['body'], remotePath, file_name)
                import hashlib  # 计算文件的MD5
                md5_obj = hashlib.md5()
                md5_obj.update(meta['body'])
                hash_code = md5_obj.hexdigest()
                md5 = str(hash_code).upper()
                v_data.ads_thumbnailurl = file_name
                v_data.ads_thumbnailurl_md5 = md5

        try:
            self.db_ads.commit()
            self.write_json(0)  # 将上传好的路径返回
        except Exception as  e:
            self.db_ads.rollback()
            log.e(e)
            self.write_json(500, "添加失败")
        finally:
            self.db_ads.close()


class adsinfoEditHander(SwxJsonHandler):
    @tornado.web.authenticated
    @tornado.gen.coroutine
    def post(self, *args, **kwargs):
        # file_metas = self.request.files.get("file", None)  # 获取上传视频信息
        file_metas_pic = self.request.files.get("file_pic", None)  # 获取上传图片信息
        task_gen = self.get_argument("task_gen", None)
        ads_id = self.get_argument("ads_id", None)
        ads_contents = self.get_argument("ads_contents", None)
        ads_name = self.get_argument("ads_name", None)
        ads_time = self.get_argument("ads_time", None)
        if not task_gen:
            self.write_json(-1, "系统错误,请重试")
            return

        v_data = self.db_ads.query(AdsInfo).filter(AdsInfo.ads_id == ads_id).first()
        v_data.ads_contents = ads_contents
        v_data.ads_name = ads_name
        v_data.ads_time = int(ads_time) if ads_time is not None else 0

        upload = app_upManager.find_task(task_gen).uploadSSH
        remotePath = cfg.file_remotePath + "/" + str(v_data.ads_id)  # 文件夹路径

        # if file_metas:
        #     for meta in file_metas:  # 循环文件信息
        #         file_name = meta['filename']  # 获取文件的名称
        #         (fn, extension) = os.path.splitext(file_name)
        #         t = int(time.time())
        #         file_name = "{}_{}{}".format(str(v_data.ads_id), t, extension)  # 文件名称
        #         yield self.upload_task(upload, meta['body'], remotePath, file_name)
        #         import hashlib  # 计算文件的MD5
        #         md5_obj = hashlib.md5()
        #         md5_obj.update(meta['body'])
        #         hash_code = md5_obj.hexdigest()
        #         md5 = str(hash_code).upper()
        #         v_data.ads_materialurl = file_name
        #         v_data.ads_materialurl_md5 = md5

        if file_metas_pic:
            for meta in file_metas_pic:  # 循环文件信息
                file_name = meta['filename']  # 获取文件的名称
                (fn, extension) = os.path.splitext(file_name)
                t = int(time.time())
                file_name = "{}_{}{}".format(str(v_data.ads_id), t, extension)  # 文件名称
                yield self.upload_task(upload, meta['body'], remotePath, file_name)
                import hashlib  # 计算文件的MD5
                md5_obj = hashlib.md5()
                md5_obj.update(meta['body'])
                hash_code = md5_obj.hexdigest()
                md5 = str(hash_code).upper()
                v_data.ads_thumbnailurl = file_name
                v_data.ads_thumbnailurl_md5 = md5

        try:
            self.db_ads.commit()
            self.write_json(0)  # 将上传好的路径返回
        except Exception as  e:
            self.db_ads.rollback()
            log.e(e)
            self.write_json(500, "修改失败")
        finally:
            self.db_ads.close()


class adsInfoVedioAddHander(SwxJsonHandler):
    @tornado.web.authenticated
    @tornado.gen.coroutine
    def post(self, *args, **kwargs):

        file_metas = self.request.files.get("file", None)  # 获取上传视频信息
        task_gen = self.get_argument("task_gen", None)
        ads_id = self.get_argument("ads_id", None)
        upload = app_upManager.find_task(task_gen).uploadSSH
        remotePath = cfg.file_remotePath + "/" + str(ads_id)  # 文件夹路径
        v_data = self.db_ads.query(AdsInfo).filter(AdsInfo.ads_id == int(ads_id)).first()
        if v_data is None:
            self.write_json(-1, '没有找到对应的素材数据')
            self.db_ads.close()
            return
        if file_metas:
            for meta in file_metas:  # 循环文件信息
                file_name = meta['filename']  # 获取文件的名称
                (fn, extension) = os.path.splitext(file_name)
                t = int(time.time())
                file_name = "{}_{}{}".format(str(ads_id), t, extension)  # 文件名称
                yield self.upload_task(upload, meta['body'], remotePath, file_name)
                import hashlib  # 计算文件的MD5
                md5_obj = hashlib.md5()
                md5_obj.update(meta['body'])
                hash_code = md5_obj.hexdigest()
                md5 = str(hash_code).upper()
                v_data.ads_materialurl = file_name
                v_data.ads_materialurl_md5 = md5
                try:
                    self.db_ads.commit()
                    self.write_json(0)  # 将上传好的路径返回
                except Exception as  e:
                    self.db_ads.rollback()
                    log.e(e)
                    self.write_json(500, "修改失败")
                finally:
                    self.db_ads.close()
        else:
            self.write_json(-1, '请添加上传视频')
            self.db_ads.close()


class adsInfoDeleteHander(SwxJsonHandler):
    @tornado.web.authenticated
    def post(self, *args, **kwargs):
        args = self.get_argument('args', None)
        if args is not None:
            args = json.loads(args)
            ids = args["ids"]
        try:
            if ids:
                self.db_ads.query(AdsInfo).filter(AdsInfo.ads_id.in_(ids)).delete(synchronize_session=False)
                self.db_ads.commit()
                self.write_json(0, 'success')
                # self.db.close()
            else:
                self.write_json(-1, '没有选中删除项')
        except Exception as  e:
            self.db_ads.rollback()
            log.e(e)
            self.write_json(500, "删除失败")
        finally:
            self.db_ads.close()


# ------------需求---------------------
class needInfoHander(SwxJsonHandler):
    @tornado.web.authenticated
    def get(self, *args, **kwargs):
        self.render("/ads_manager/need_info/needinfo_list.mako")

    @tornado.web.authenticated
    def post(self, *args, **kwargs):
        limit, args = self.get_pages_args()

        sql = "SELECT  n.need_id,p.package_name,n.need_play_type,n.anchor_level,n.position,n.ads_id,n.enable,n.logtime,n.description" \
              ",n.need_name from ads_need_info n  LEFT JOIN ads_contract_package_info p ON n.package_id=p.package_id where 1=1"

        filter = args["filter"]
        name = ""
        if "search" in filter.keys():
            name = filter["search"]
        if name is not None and name != "":
            sql = sql + " and n.need_name like '%" + name.strip() + "%' "
        offset = " ORDER BY n.need_id DESC LIMIT {},{}".format(limit['page_index'] * 10, limit['per_page'])
        datas = self.db_ads.execute(sql + offset).fetchall()

        lst = list()
        for data in datas:
            need_id = data[0]
            package_name = data[1]
            need_play_type = data[2]
            anchor_level = data[3]
            position = data[4]
            ads_id = data[5]
            enable = data[6]
            logtime = data[7].isoformat()

            description = data[8]
            need_name = data[9]
            lst.append({"need_id": need_id, "package_name": package_name, "need_play_type": need_play_type,
                        "description": description,
                        "anchor_level": anchor_level, "position": position, "ads_id": ads_id, "enable": enable,
                        "logtime": logtime,
                        "need_name": need_name})

        count = self.db_ads.execute("select count(*) from({}) as count_data".format(sql)).scalar()
        ret = dict()
        ret['page_index'] = limit['page_index']
        ret['total'] = count
        ret['data'] = lst

        self.write_json(0, data=ret)
        self.db_ads.close()


#

class adsInfoFindByIdHander(SwxJsonHandler):
    def get(self, *args, **kwargs):
        id = self.get_argument("id", None)
        data = self.db_ads.query(AdsInfo).filter(AdsInfo.ads_id == id).first()
        lst = json.loads(json.dumps(data, cls=AlchemyEncoder))
        self.write_raw_json(lst)
        self.db_ads.close()


# 素材List

class adsInfoSelect4AllHander(SwxJsonHandler):
    def get(self, *args, **kwargs):
        ads_list = self.db_ads.query(AdsInfo).all()
        lst = list()
        for ptype in ads_list:
            lst.append(json.loads(json.dumps(ptype, cls=AlchemyEncoder)))
        self.write_raw_json(lst)
        self.db_ads.close()


class GroupInfoSelect4AllHander(SwxJsonHandler):
    def get(self, *args, **kwargs):
        group_list = self.db_ads.query(NeedGroupInfo).all()
        lst = list()
        for group in group_list:
            lst.append(json.loads(json.dumps(group, cls=AlchemyEncoder)))
        self.write_raw_json(lst)
        self.db_ads.close()


# ContractPackInfo    List
class contPackInfoSelect4AllHander(SwxJsonHandler):
    def get(self, *args, **kwargs):
        ads_list = self.db_ads.query(ContractPackInfo).all()
        lst = list()
        for ptype in ads_list:
            lst.append(json.loads(json.dumps(ptype, cls=AlchemyEncoder)))
        self.write_raw_json(lst)

        self.db_ads.close()


####---------------合同---------------------------------
class contractInfoHander(SwxJsonHandler):
    @tornado.web.authenticated
    def get(self, *args, **kwargs):
        self.render("/ads_manager/contract_info/contractinfo_list.mako")

    @tornado.web.authenticated
    def post(self, *args, **kwargs):
        limit, args = self.get_pages_args()
        filter = args["filter"]
        contractid = ''
        if "search" in filter.keys():
            contractid = filter["search"]
        query = self.db_ads.query(AdsContractInfo)
        if contractid:
            # name = '%' + name + '%'
            query = query.filter(AdsContractInfo.contract_id == contractid)
        total = query.count()
        query = query.order_by(AdsContractInfo.contract_id.desc())
        query = query.limit(int(limit['per_page'])).offset(
            (int(limit['page_index'] * 10)))
        query_result = query.all()

        lst = list()
        for item in query_result:
            lst.append({
                'contract_id': item.contract_id or '',
                'contract_name': item.contract_name or '',
                'contract_price': item.contract_price or '',
                'adsver_id': item.adsver_id or '',
                'contract_desc': item.contract_desc or '',
                'create_time': item.create_time.isoformat() or '',
            })
        ret = dict()
        ret['page_index'] = limit['page_index']
        ret['total'] = total
        ret['data'] = lst
        self.write_json(0, data=ret)
        self.db_ads.close()


class contractAddInfoHander(SwxJsonHandler):
    @tornado.web.authenticated
    @tornado.gen.coroutine
    def post(self, *args, **kwargs):

        contract_name = self.get_argument("contract_name", None)
        contract_price = self.get_argument("contract_price", None)
        adsver_id = self.get_argument("adsver_id", None)
        contract_desc = self.get_argument("contract_desc", None)

        args = self.get_argument('args', None)
        if args is not None:
            args = json.loads(args)
            # create_time = args["create_time"]
            contract_name = args["contract_name"]
            contract_price = args["contract_price"]
            adsver_id = args["adsver_id"]
            contract_desc = args["contract_desc"]

        try:
            date_now = datetime.datetime.now()
            item = AdsContractInfo(contract_name=contract_name, contract_price=contract_price, adsver_id=adsver_id,
                                   contract_desc=contract_desc,
                                   create_time=date_now
                                   )
            self.db_ads.add(item)
            self.db_ads.commit()

            self.write_json(0)  # 将上传好的路径返回
        except Exception as e:
            self.db_ads.rollback()
            log.e(e)
            self.write_json(500, "更新失败")
        finally:
            self.db_ads.close()

        self.db_ads.close()


class contractDelInfoHander(SwxJsonHandler):
    @tornado.web.authenticated
    def post(self, *args, **kwargs):
        args = self.get_argument('args', None)
        if args is not None:
            args = json.loads(args)
            ids = args["ids"]
        try:
            if ids:
                self.db_ads.query(AdsContractInfo).filter(AdsContractInfo.contract_id.in_(ids)).delete(
                    synchronize_session=False)
                self.db_ads.commit()
                self.write_json(0, 'success')
                # self.db.close()
            else:
                self.write_json(-1, '没有选中删除项')
        except Exception as  e:
            self.db_ads.rollback()
            log.e(e)
            self.write_json(500, "删除失败")
        finally:
            self.db_ads.close()


class contractEdInfoHander(SwxJsonHandler):
    @tornado.web.authenticated
    @tornado.gen.coroutine
    def post(self, *args, **kwargs):

        contract_id = self.get_argument("contract_id", None)
        contract_name = self.get_argument("contract_name", None)
        contract_price = self.get_argument("contract_price", None)
        adsver_id = self.get_argument("adsver_id", None)
        contract_desc = self.get_argument("contract_desc", None)

        args = self.get_argument('args', None)
        if args is not None:
            args = json.loads(args)
            contract_id = args["contract_id"]
            contract_name = args["contract_name"]
            contract_price = args["contract_price"]
            adsver_id = args["adsver_id"]
            contract_desc = args["contract_desc"]

        try:
            self.db_ads.query(AdsContractInfo).filter(AdsContractInfo.contract_id == contract_id).update(
                {AdsContractInfo.contract_name: contract_name, AdsContractInfo.contract_price: contract_price,
                 AdsContractInfo.adsver_id: adsver_id, AdsContractInfo.contract_desc: contract_desc})
            # sql_session.update({TStatUnionConfig.eff_airtime: time_len})

            self.db_ads.commit()
            self.write_json(0)  # 将上传好的路径返回
        except Exception as e:
            self.db_ads.rollback()
            log.e(e)
            self.write_json(500, "更新失败")
        finally:
            self.db_ads.close()

        self.db_ads.close()


class NeedInfoFindByIdIdHander(SwxJsonHandler):
    def get(self, *args, **kwargs):
        id = self.get_argument("id", None)
        data = self.db_ads.query(NeedInfo).filter(NeedInfo.need_id == id).first()
        lst = json.loads(json.dumps(data, cls=AlchemyEncoder))
        self.write_raw_json(lst)
        self.db_ads.close()


class NeedInfoAddHander(SwxJsonHandler):
    @tornado.web.authenticated
    def post(self, *args, **kwargs):
        args = self.get_argument('args', None)
        if args is not None:
            args = json.loads(args)
        package_id = args["package_id"]
        need_play_type = args["need_play_type"]
        anchor_level = args["anchor_level"]
        position = args["position"]
        ads_id = args["ads_id"]
        description = args["description"]
        enable = args["enable"]
        need_name = args["need_name"]
        needinfo = NeedInfo()
        needinfo.package_id = package_id
        needinfo.need_play_type = need_play_type
        needinfo.anchor_level = anchor_level
        needinfo.position = position
        needinfo.ads_id = ads_id
        position_count = len(position.split(",")) if position is not None else 0
        needinfo.position_count = position_count
        needinfo.description = description
        needinfo.enable = enable
        needinfo.need_name = need_name
        self.db_ads.add(needinfo)
        try:
            self.db_ads.commit()
            self.write_json(0, "success")
        except Exception as e:
            self.db_ads.rollback()
            log.e(e)
            self.write_json(500, "系统错误")
        finally:
            self.db_ads.close()


class NeedInfoEditHander(SwxJsonHandler):
    @tornado.web.authenticated
    def post(self, *args, **kwargs):
        args = self.get_argument('args', None)
        if args is not None:
            args = json.loads(args)
        package_id = args["package_id"]
        need_play_type = args["need_play_type"]
        anchor_level = args["anchor_level"]
        position = args["position"]
        ads_id = args["ads_id"]
        description = args["description"]
        enable = args["enable"]
        need_name = args["need_name"]
        id = args["id"]
        v_data = self.db_ads.query(NeedInfo).filter(NeedInfo.need_id == id).first()
        v_data.package_id = package_id
        v_data.need_play_type = need_play_type
        v_data.anchor_level = anchor_level
        v_data.position = position
        v_data.ads_id = ads_id
        v_data.description = description
        v_data.enable = enable
        v_data.need_name = need_name
        position_count = len(position.split(",")) if position is not None else 0
        v_data.position_count = position_count
        try:
            self.db_ads.commit()
            self.write_json(0, "success")
        except Exception as e:
            self.db_ads.rollback()
            log.e(e)
            self.write_json(500, "系统错误")
        finally:
            self.db_ads.close()


class needInfoDeleteHander(SwxJsonHandler):
    @tornado.web.authenticated
    def post(self, *args, **kwargs):
        args = self.get_argument('args', None)
        if args is not None:
            args = json.loads(args)
            ids = args["ids"]
        try:
            if ids:
                self.db_ads.query(NeedInfo).filter(NeedInfo.need_id.in_(ids)).delete(synchronize_session=False)
                self.db_ads.commit()
                self.write_json(0, 'success')
                # self.db.close()
            else:
                self.write_json(-1, '没有选中删除项')
        except Exception as  e:
            self.db_ads.rollback()
            log.e(e)
            self.write_json(500, "删除失败")
        finally:
            self.db_ads.close()


# needinfo  List
class NeedInfo4AllHander(SwxJsonHandler):
    def get(self, *args, **kwargs):
        anchor_level = self.get_argument("anchor_level", None)
        package_id = self.get_argument("package_id", None)
        query = self.db_ads.query(NeedInfo)
        if anchor_level is not None and anchor_level != "":
            query = query.filter(NeedInfo.anchor_level == anchor_level)
        if package_id is not None and package_id != "":
            query = query.filter(NeedInfo.package_id == package_id)
        ni_list = query.all()
        lst = list()
        for n in ni_list:
            lst.append(json.loads(json.dumps(n, cls=AlchemyEncoder)))
        self.write_raw_json(lst)
        self.db_ads.close()


class needGroupInfoHander(SwxJsonHandler):
    @tornado.web.authenticated
    def get(self, *args, **kwargs):
        self.render("/ads_manager/need_group/needgroup_list.mako")

    @tornado.web.authenticated
    def post(self, *args, **kwargs):
        limit, args = self.get_pages_args()
        sql = "SELECT group_name,ads_need_group_id,comment,(SELECT GROUP_CONCAT(a.ads_need_id)  as need_ids FROM ads_group_need_map a where a.ads_group_id=b.ads_need_group_id) as need_id," \
              "logtime,anchor_level from ads_group_info b where 1=1"
        filter = args["filter"]
        name = ""
        if "search" in filter.keys():
            name = filter["search"]
        if name is not None and name != "":
            sql = sql + " and group_name like '%" + name.strip() + "%' "
        offset = " ORDER BY ads_need_group_id DESC LIMIT {},{}".format(limit['page_index'] * 10, limit['per_page'])
        datas = self.db_ads.execute(sql + offset).fetchall()

        lst = list()
        for data in datas:
            group_name = data[0]
            ads_need_group_id = data[1]
            # anchor_alloc_type = data[2]
            comment = data[2]
            need_id = data[3]
            logtime = data[4].isoformat()
            anchor_level = data[5]
            lst.append({"group_name": group_name, "ads_need_group_id": ads_need_group_id,
                        "comment": comment, "logtime": logtime, "need_id": need_id, "anchor_level": anchor_level})

        count = self.db_ads.execute("select count(*) from({}) as count_data".format(sql)).scalar()
        ret = dict()
        ret['page_index'] = limit['page_index']
        ret['total'] = count
        ret['data'] = lst
        self.write_json(0, data=ret)
        self.db_ads.close()


class NeedGroupInfoAddHander(SwxJsonHandler):
    @tornado.web.authenticated
    def post(self, *args, **kwargs):
        args = self.get_argument('args', None)
        if args is not None:
            args = json.loads(args)
        group_name = args["group_name"]
        comment = args["comment"]
        anchor_level = args["anchor_level"]
        if group_name is not None:
            num = self.db_ads.query(NeedGroupInfo).filter(NeedGroupInfo.group_name == group_name).count()
            if num > 0:
                self.write_json(-1, "分组名称不能重复")
                return
        ng = NeedGroupInfo()
        ng.group_name = group_name
        ng.comment = comment
        ng.anchor_level = anchor_level
        self.db_ads.add(ng)
        try:
            self.db_ads.commit()
            self.write_json(0, "success")
        except Exception as e:
            self.db_ads.rollback()
            log.e(e)
            self.write_json(500, "系统错误")
        finally:
            self.db_ads.close()


class NeedGroupInfoEditHander(SwxJsonHandler):
    @tornado.web.authenticated
    def post(self, *args, **kwargs):
        args = self.get_argument('args', None)
        if args is not None:
            args = json.loads(args)
        group_name = args["group_name"]
        comment = args["comment"]
        anchor_level = args["anchor_level"]
        id = args["id"]
        v_data = self.db_ads.query(NeedGroupInfo).filter(NeedGroupInfo.ads_need_group_id == id).first()

        # 如果等级发生改变删除所有 映射map
        if anchor_level != v_data.anchor_level:
            self.db_ads.query(GroupNeedMap).filter(GroupNeedMap.ads_group_id == id).delete(
                synchronize_session=False)
        v_data.group_name = group_name
        v_data.comment = comment
        v_data.anchor_level = anchor_level

        try:
            self.db_ads.commit()
            self.write_json(0, "success")
        except Exception as e:
            self.db_ads.rollback()
            log.e(e)
            self.write_json(500, "系统错误")
        finally:
            self.db_ads.close()


class NeedGroupInfoAllHander(SwxJsonHandler):
    def get(self, *args, **kwargs):
        ngi_list = self.db_ads.query(NeedGroupInfo).all()
        lst = list()
        for ngi in ngi_list:
            lst.append(json.loads(json.dumps(ngi, cls=AlchemyEncoder)))
        self.write_raw_json(lst)
        self.db_ads.close()


class NeedGroupInfoDeleteHander(SwxJsonHandler):
    @tornado.web.authenticated
    def post(self, *args, **kwargs):
        args = self.get_argument('args', None)
        if args is not None:
            args = json.loads(args)
            ids = args["ids"]
        try:
            if ids:
                self.db_ads.query(NeedGroupInfo).filter(NeedGroupInfo.ads_need_group_id.in_(ids)).delete(
                    synchronize_session=False)
                self.db_ads.commit()
                self.write_json(0, 'success')
                # self.db.close()
            else:
                self.write_json(-1, '没有选中删除项')
        except Exception as  e:
            self.db_ads.rollback()
            log.e(e)
            self.write_json(500, "删除失败")
        finally:
            self.db_ads.close()


class needScheduleHander(SwxJsonHandler):
    @tornado.web.authenticated
    def get(self, *args, **kwargs):
        self.render("/ads_manager/need_schedule/needschedule_list.mako")

    @tornado.web.authenticated
    def post(self, *args, **kwargs):

        limit, args = self.get_pages_args()
        sql = "SELECT  s.schedule_id,g.group_name,s.count,s.anchor_if_exp," \
              "s.lv_priority,s.logtime,s.schedule_create_time,s.start_alloc_time,s.schedule_name from ads_need_schedule s" \
              " LEFT JOIN ads_group_info g on s.group_id=g.ads_need_group_id where 1=1"
        filter = args["filter"]
        name = ""
        if "search" in filter.keys():
            name = filter["search"]
        if name is not None and name != "":
            sql = sql + " and g.group_name like '%" + name.strip() + "%' "
        offset = " ORDER BY s.schedule_id DESC LIMIT {},{}".format(limit['page_index'] * 10, limit['per_page'])
        datas = self.db_ads.execute(sql + offset).fetchall()

        lst = list()
        for data in datas:
            schedule_id = data[0]
            group_name = data[1]
            count = data[2]
            anchor_if_exp = data[3]
            lv_priority = data[4]
            logtime = data[5].isoformat()
            schedule_create_time = data[6].isoformat()
            start_alloc_time = data[7].isoformat()
            schedule_name = data[8]
            lst.append({"schedule_id": schedule_id, "group_name": group_name, "count": count,
                        "anchor_if_exp": anchor_if_exp,
                        "lv_priority": lv_priority, "schedule_name": schedule_name,
                        "logtime": logtime,
                        "start_alloc_time": start_alloc_time,
                        "schedule_create_time": schedule_create_time})

        count = self.db_ads.execute("select count(*) from({}) as count_data".format(sql)).scalar()
        ret = dict()
        ret['page_index'] = limit['page_index']
        ret['total'] = count
        ret['data'] = lst
        self.write_json(0, data=ret)
        self.db_ads.close()


class needScheduleHander_shchedule(SwxJsonHandler):
    @tornado.web.authenticated
    def get(self, *args, **kwargs):
        id = self.get_argument("id", None)
        sql = "SELECT  s.schedule_id,g.group_name,s.count,s.anchor_if_exp,s.lv_priority,s.logtime,s.schedule_create_time from ads_need_schedule s LEFT JOIN ads_group_info g on s.group_id=g.ads_need_group_id where 1=1"
        # filter = args["filter"]
        # name = ""
        sql = sql + " and s.schedule_id = " + id + ""
        datas = self.db_ads.execute(sql).fetchone()
        if datas:
            schedule_id = datas[0]
            group_name = datas[1]
            count = datas[2]
            anchor_if_exp = datas[3]
            lv_priority = datas[4]
            logtime = datas[5].isoformat()
            schedule_create_time = datas[6].isoformat()
            lst = {"schedule_id": schedule_id, "group_name": group_name, "count": count,
                   "anchor_if_exp": anchor_if_exp,
                   "lv_priority": lv_priority,
                   "logtime": logtime,
                   "schedule_create_time": schedule_create_time}
            # count = self.db_ads.execute("select count(*) from({}) as count_data".format(sql)).scalar()

            self.write_json(0, '', lst)
            # self.write_json(0, data=ret)
            self.db_ads.close()
        else:
            self.write_json(-1, '没有对应的schedule数据')
            self.db_ads.close()
            return


# 输入group_id 获取对应信息
class needScheduleHander_group(SwxJsonHandler):
    @tornado.web.authenticated
    def get(self, *args, **kwargs):
        id = self.get_argument("id", None)
        sql = "SELECT group_name,ads_need_group_id,anchor_alloc_type,comment,(SELECT GROUP_CONCAT(a.ads_need_id)  as need_ids FROM ads_group_need_map a where a.ads_group_id=b.ads_need_group_id) as need_id," \
              "logtime,anchor_level from ads_group_info b where 1=1"
        # filter = args["filter"]
        # name = ""
        sql = sql + " and b.ads_need_group_id = " + id + ""
        datas = self.db_ads.execute(sql).fetchone()

        group_name = datas[0]
        ads_need_group_id = datas[1]
        anchor_alloc_type = datas[2]
        comment = datas[3]
        need_id = datas[4]
        logtime = datas[5].isoformat()
        anchor_level = datas[6]
        lst = {"group_name": group_name, "ads_need_group_id": ads_need_group_id, "anchor_alloc_type": anchor_alloc_type,
               "comment": comment,
               "need_id": need_id,
               "logtime": logtime,
               "anchor_level": anchor_level}
        # count = self.db_ads.execute("select count(*) from({}) as count_data".format(sql)).scalar()

        self.write_json(0, '', lst)
        # self.write_json(0, data=ret)
        self.db_ads.close()


class needScheduleAddHander(SwxJsonHandler):
    @tornado.web.authenticated
    def get(self, *args, **kwargs):
        self.render("/ads_manager/need_schedule/needshcdule_create.mako")

    @tornado.web.authenticated
    def post(self, *args, **kwargs):
        param = self.get_argument("param")
        if param is not None:
            param = json.loads(param)
            for p in param:
                group_name = p["group_name"]
                group_id = p["group_id"]
                count = p["count"]
                anchor_if_exp = p["anchor_if_exp"]
                lv_priority = p["lv_priority"]
                create_time = p["create_time"]
                assign_flag = p["assign_flag"]
                ns = NeedSchedule()
                ns.group_id = int(group_id)
                ns.count = int(count)
                ns.anchor_if_exp = anchor_if_exp
                ns.lv_priority = lv_priority
                ns.schedule_create_time = create_time

                today = create_time[0:11] if create_time != "" else ""
                date_time = datetime.datetime.strptime(today.strip(), '%Y-%m-%d')
                tomorrow = date_time + datetime.timedelta(days=1)
                tomorrowstr = tomorrow.strftime("%Y-%m-%d")

                ns.schedule_destroy_time = tomorrowstr + " 05:00:00"
                ns.start_alloc_time = create_time
                ns.start_play_time = create_time
                ns.end_play_time = create_time
                ns.end_alloc_time = today + " 23:59:00"
                ns.assign_flag = '0'
                ns.flag = '0'
                ns.schedule_state = '0'
                ns.assign_flag = assign_flag
                ns.description = group_name
                d = datetime.datetime.strptime(create_time,'%Y-%m-%d %H:%M:%S')
                time_temp = str(d.time())
                name_temp = ''
                if time_temp > "00:00:00" and time_temp <= "06:00:00":
                    name_temp = '早上'
                if time_temp > "06:00:00" and time_temp <= "12:00:00":
                    name_temp = '中午'
                if time_temp > "12:00:00" and time_temp <= "18:00:00":
                    name_temp = '下午'
                if time_temp > "18:00:00" and time_temp <= "24:00:00":
                    name_temp = '晚上'
                # print(name_temp)

                ns.schedule_name = group_name+" 【"+name_temp+"】"
                ns.schedule_enable = '1'
                ns.enable = '1'
                self.db_ads.add(ns)
                try:
                    self.db_ads.commit()

                    oplog = AdsOpLog()
                    oplog.op_type = 5
                    user = self.get_current_user()
                    oplog.op_user_id = user["id"]
                    oplog.op_user_name = user["name"]
                    oplog.op_desc = '添加 schedule schedule_id:' + str(ns.schedule_id)
                    oc = {"schedule_id": ns.schedule_id,"count":count,"anchor_if_exp":anchor_if_exp,"create_time":create_time}
                    oplog.op_content = str(oc)
                    oplog.createtime = datetime.datetime.now()
                    self.db_ads.add(oplog)
                    self.db_ads.commit()

                except Exception as e:
                    self.db_ads.rollback()
                    log.e(e)
                    self.write_json(500, "添加失败")
                    return
                finally:
                    self.db_ads.close()
            self.write_json(0)
        else:
            self.write_json(-1, "没有需要添加的schedule数据")


class needScheduleUpdateHander(SwxJsonHandler):
    @tornado.web.authenticated
    def post(self, *args, **kwargs):
        args = self.get_argument("args")
        if args is not None:
            args = json.loads(args)
            group_name = args["group_name"]
            count = args["count"]
            anchor_if_exp = args["anchor_if_exp"]
            lv_priority = args["lv_priority"]
            schedule_create_time = args["schedule_create_time"]
            id = args["id"]
            ns = self.db_ads.query(NeedSchedule).filter(NeedSchedule.schedule_id == id).first()
            ns.group_id = int(group_name)
            ns.count = int(count)
            ns.anchor_if_exp = anchor_if_exp
            ns.lv_priority = lv_priority
            ns.schedule_create_time = schedule_create_time
            ns.schedule_destroy_time = schedule_create_time
            ns.start_alloc_time = schedule_create_time
            ns.end_alloc_time = schedule_create_time
            try:
                self.db_ads.commit()
                self.write_json(0)
            except Exception as e:
                self.db_ads.rollback()
                log.e(e)
                self.write_json(500, "修改失败")
            finally:
                self.db_ads.close()


class needScheduleDeleteHander(SwxJsonHandler):
    @tornado.web.authenticated
    def post(self, *args, **kwargs):
        args = self.get_argument('args', None)
        if args is not None:
            args = json.loads(args)
            ids = args["ids"]
        try:
            if ids:
                self.db_ads.query(NeedSchedule).filter(NeedSchedule.schedule_id.in_(ids)).delete(
                    synchronize_session=False)
                self.db_ads.commit()
                self.write_json(0, 'success')
            else:
                self.write_json(-1, '没有选中删除项')
        except Exception as  e:
            self.db_ads.rollback()
            log.e(e)
            self.write_json(500, "删除失败")
        finally:
            self.db_ads.close()


class needScheduleRetractHander(SwxJsonHandler):
    @tornado.web.authenticated
    def post(self, *args, **kwargs):
        args = self.get_argument('args', None)
        if args is not None:
            args = json.loads(args)
            schedule_id = args["schedule_id"]
        try:
            if schedule_id:
                # self.db_ads.query(NeedSchedule).filter(NeedSchedule.schedule_id == schedule_id).delete(
                #     synchronize_session=False)
                self.db_ads.query(AdsNeedPlanInfo).filter(AdsNeedPlanInfo.schedule_id == schedule_id,
                                                          AdsNeedPlanInfo.task_id == 0).delete(
                    synchronize_session=False)

                oplog = AdsOpLog()
                oplog.op_type = 1
                user = self.get_current_user()
                oplog.op_user_id = user["id"]
                oplog.op_user_name = user["name"]
                oplog.op_desc = '撤回 schedule schedule_id:' + str(schedule_id)
                oc = {"schedule_id": schedule_id}
                oplog.op_content = str(oc)
                oplog.createtime = datetime.datetime.now()
                self.db_ads.add(oplog)

                self.db_ads.commit()
                self.write_json(0, 'success')
            else:
                self.write_json(-1, '没有选中删除项')
        except Exception as  e:
            self.db_ads.rollback()
            log.e(e)
            self.write_json(500, "删除失败")
        finally:
            self.db_ads.close()


class needScheduleIMInfoHanderAll(SwxJsonHandler):
    @tornado.web.authenticated
    @tornado.gen.coroutine
    def post(self, *args, **kwargs):
        schedule_id = self.get_argument("schedule_id", None)
        sql_session = None
        session_anchor = None
        upload_path = os.path.join(os.path.dirname(__file__) + '/../../..', 'UploadFiles')  # 文件的暂存路径

        # aa=os.path.dirname(os.getcwd())
        try:

            file_metas = self.request.files['infile']  # 提取表单中‘name’为‘infile’的文件元数据
            data_now_str = datetime.datetime.now().strftime('%Y%m%d%H%M%S')
            # 根据公会名，查询公会的id
            if not os.path.exists(upload_path):
                os.mkdir(upload_path)
            for meta in file_metas:
                filename = data_now_str + '(' + meta['filename'] + ')'
                filepath = os.path.join(upload_path, filename)
                with open(filepath, 'wb') as up:  # 有些文件需要已二进制的形式存储，实际中可以更改
                    up.write(meta['body'])
            # 读取文件
            workbook = xlrd.open_workbook(filepath)
            os.remove(os.path.join(upload_path, filename))
            # 拿到表名
            sheets = workbook.sheet_names()

            # 第一个表
            worksheet = workbook.sheet_by_name(sheets[0])
            # 行数
            nrows = worksheet.nrows
            if nrows <= 1:
                self.write_json(0, '上传表格错误(表格不能为空表且数据从第二行开始)')
                return
            ret = list()

            for i in range(1, worksheet.nrows):
                temp = dict()
                temp['plat_id'] = int(worksheet.cell(i, 0).value)
                temp['room_id'] = int(worksheet.cell(i, 1).value)
                # temp['ads_schedule_id'] = int(worksheet.cell(i, 2).value)
                temp['comment'] = str(worksheet.cell(i, 3).value)
                # date = xldate_as_tuple(worksheet.cell(i, 4).value, 0)
                # temp['create_time'] = datetime.datetime(*date)
                query = self.db_ads.query(AdsConfigAnchorWhitelist).filter(
                    and_(AdsConfigAnchorWhitelist.plat_id == temp['plat_id'],
                         AdsConfigAnchorWhitelist.room_id == temp['room_id'],
                         AdsConfigAnchorWhitelist.ads_schedule_id == schedule_id)).all()
                if query:
                    print('该次重复,room_id:' + str(temp['room_id']))
                else:
                    ret.append(temp)

            import_time = data_now_str
            for item in ret:
                item = AdsConfigAnchorWhitelist(plat_id=item['plat_id'], room_id=item['room_id'],
                                                ads_schedule_id=schedule_id,
                                                comment=item['comment']
                                                )

                self.db_ads.add(item)
                self.db_ads.commit()

            self.write_json(1, '上传成功')
            return
        # 认证公会审核通过（4.0）
        except Exception as e:
            # session.rollback()
            log.e('admin.roomImportAdsInfo_error:' + str(e))
            self.write_json(0, 'excel数据格式错误,请查看 url 模式 roomid 模式是否写反,error:{}'.format(e))
            return
        finally:
            if sql_session:
                sql_session.close()
            if session_anchor:
                session_anchor.close()


####---------------合同(对应的套餐包)---------------------------------
class ContractPackageInfoHander(SwxJsonHandler):
    def get(self, *args, **kwargs):
        id = self.get_argument("id", None)
        data = self.db_ads.query(ContractPackInfo).filter(ContractPackInfo.contract_id == id).first()
        lst = json.loads(json.dumps(data, cls=AlchemyEncoder))
        if data:
            need_desc = json.loads(data.need_desc)
            if need_desc:
                lst['S'] = str(need_desc['S'])
                lst['A'] = str(need_desc['A'])
                lst['B'] = str(need_desc['B'])
                lst['C'] = str(need_desc['C'])
                lst['D'] = str(need_desc['D'])
            else:
                self.write_json(-1, '没有对应的套餐数据')
                self.db_ads.close()
                return
        else:
            self.write_json(-1, '没有对应的套餐数据')
            self.db_ads.close()
            return
        self.write_json(0, '', lst)
        self.db_ads.close()


####---------------套餐---------------------------------
class ContractPackageInfoHanderAll(SwxJsonHandler):
    @tornado.web.authenticated
    def get(self, *args, **kwargs):
        self.render("/ads_manager/contractpackage_info/contractpackage_list.mako")

    @tornado.web.authenticated
    def post(self, *args, **kwargs):
        limit, args = self.get_pages_args()
        filter = args["filter"]
        packageid = ''
        if "search" in filter.keys():
            packageid = filter["search"]
        query = self.db_ads.query(ContractPackInfo)
        if packageid:
            query = query.filter(ContractPackInfo.package_id == packageid)

        total = query.count()
        query = query.order_by(ContractPackInfo.package_id.desc())
        query = query.limit(int(limit['per_page'])).offset(
            (int(limit['page_index'] * 10)))
        query_result = query.all()
        # total = query.count()

        lst = list()
        S = 0
        A = 0
        B = 0
        C = 0
        D = 0

        for item in query_result:
            if query_result:
                if item.need_desc:
                    need_desc_json = json.loads(item.need_desc)
                    S = str(need_desc_json['S'])
                    A = str(need_desc_json['A'])
                    B = str(need_desc_json['B'])
                    C = str(need_desc_json['C'])
                    D = str(need_desc_json['D'])
                else:
                    S = 0
                    A = 0
                    B = 0
                    C = 0
                    D = 0
            lst.append({
                'package_id': item.package_id or '',
                'package_name': item.package_name or '',
                'contract_id': item.contract_id or '',
                'package_price': str(item.package_price) or '',
                'begin_time': item.begin_time.isoformat() or '',
                'end_time': item.end_time.isoformat() or '',
                'anchor_need': item.anchor_need or '',
                'anchor_play_count': item.anchor_play_count or '',
                'need_desc': item.need_desc or '',
                'S': S,
                'A': A,
                'B': B,
                'C': C,
                'D': D,
            })
        ret = dict()
        ret['page_index'] = limit['page_index']
        ret['total'] = total
        ret['data'] = lst
        self.write_json(0, data=ret)
        self.db_ads.close()


class ContractAddPackageInfoHanderAll(SwxJsonHandler):
    @tornado.web.authenticated
    @tornado.gen.coroutine
    def post(self, *args, **kwargs):

        package_name = self.get_argument("package_name", None)
        contract_id = self.get_argument("contract_id", None)
        package_price = self.get_argument("package_price", None)
        begin_time = self.get_argument("begin_time", None)
        end_time = self.get_argument("end_time", None)
        anchor_need = self.get_argument("anchor_need", None)
        anchor_play_count = self.get_argument("anchor_play_count", None)
        S = self.get_argument("S", None)
        A = self.get_argument("A", None)
        B = self.get_argument("B", None)
        C = self.get_argument("C", None)
        D = self.get_argument("D", None)
        need_desc = {}
        args = self.get_argument('args', None)
        if args is not None:
            args = json.loads(args)
            # create_time = args["create_time"]
            package_name = args["package_name"]
            contract_id = args["contract_id"]
            package_price = args["package_price"]
            begin_time = args["begin_time"]
            end_time = args["end_time"]
            anchor_need = args["anchor_need"]
            anchor_play_count = args["anchor_play_count"]
            S = args["S"]
            A = args["A"]
            B = args["B"]
            C = args["C"]
            D = args["D"]
            need_desc = {
                "S": S,
                "A": A,
                "B": B,
                "C": C,
                "D": D
            }
            need_desc = json.dumps(need_desc)

        try:
            date_now = datetime.datetime.now()
            item = ContractPackInfo(package_name=package_name, contract_id=contract_id, package_price=package_price,
                                    begin_time=begin_time, end_time=end_time,
                                    anchor_need=anchor_need, status=1,
                                    anchor_play_count=anchor_play_count, need_desc=need_desc, create_time=date_now
                                    )
            self.db_ads.add(item)
            self.db_ads.commit()

            self.write_json(0)  # 将上传好的路径返回
        except Exception as e:
            self.db_ads.rollback()
            log.e(e)
            self.write_json(500, "新增失败")
        finally:
            self.db_ads.close()

        self.db_ads.close()


class ContractDelPackageInfoHanderAll(SwxJsonHandler):
    @tornado.web.authenticated
    def post(self, *args, **kwargs):
        args = self.get_argument('args', None)
        if args is not None:
            args = json.loads(args)
            ids = args["ids"]
        try:
            if ids:
                self.db_ads.query(ContractPackInfo).filter(ContractPackInfo.package_id.in_(ids)).delete(
                    synchronize_session=False)
                self.db_ads.commit()
                self.write_json(0, 'success')
                # self.db.close()
            else:
                self.write_json(-1, '没有选中删除项')
        except Exception as  e:
            self.db_ads.rollback()
            log.e(e)
            self.write_json(500, "删除失败")
        finally:
            self.db_ads.close()


class ContractEdPackageInfoHanderAll(SwxJsonHandler):
    @tornado.web.authenticated
    @tornado.gen.coroutine
    def post(self, *args, **kwargs):
        args = self.get_argument('args', None)
        if args is not None:
            args = json.loads(args)
            package_id = args["package_id"]
            package_name = args["package_name"]
            contract_id = args["contract_id"]
            package_price = args["package_price"]
            begin_time = args["begin_time"]
            end_time = args["end_time"]
            anchor_need = args["anchor_need"]
            anchor_play_count = args["anchor_play_count"]
            S = args["S"]
            A = args["A"]
            B = args["B"]
            C = args["C"]
            D = args["D"]
            need_desc = {
                "S": S,
                "A": A,
                "B": B,
                "C": C,
                "D": D
            }
            need_desc = json.dumps(need_desc)

        try:
            self.db_ads.query(ContractPackInfo).filter(ContractPackInfo.package_id == package_id).update(
                {ContractPackInfo.package_name: package_name, ContractPackInfo.contract_id: contract_id,
                 ContractPackInfo.end_time: end_time, ContractPackInfo.anchor_need: anchor_need,
                 ContractPackInfo.anchor_play_count: anchor_play_count,
                 ContractPackInfo.need_desc: need_desc,
                 ContractPackInfo.package_price: package_price, ContractPackInfo.begin_time: begin_time})
            # sql_session.update({TStatUnionConfig.eff_airtime: time_len})

            self.db_ads.commit()
            self.write_json(0)  # 将上传好的路径返回
        except Exception as e:
            self.db_ads.rollback()
            log.e(e)
            self.write_json(500, "更新失败")
        finally:
            self.db_ads.close()

        self.db_ads.close()


class GroupNeedMapUpdateHander(SwxJsonHandler):
    def post(self, *args, **kwargs):
        args = self.get_argument('args', None)
        if args is not None:
            args = json.loads(args)
            need_id = args["need_id"]
            group_id = args["group_id"]
            ifselect = args["ifselect"]
            type = args["type"]
            old_need_id = args["old_need_id"]

        if ifselect == False and need_id != "":
            # 删除
            self.db_ads.query(GroupNeedMap).filter(GroupNeedMap.ads_group_id == group_id,
                                                   GroupNeedMap.ads_need_id == need_id).delete(
                synchronize_session=False)


        elif ifselect == True and old_need_id != "":

            num = self.db_ads.query(GroupNeedMap).filter(GroupNeedMap.ads_need_id == need_id,
                                                         GroupNeedMap.ads_group_id == group_id).count()
            if num > 0:
                self.write_json(-1, "该分组已包含need_id")
                return

            v_data = self.db_ads.query(GroupNeedMap).filter(GroupNeedMap.ads_need_id == old_need_id,
                                                            GroupNeedMap.ads_group_id == group_id).first()
            if v_data is not None and type == "update":
                # 修改
                v_data.ads_need_id = need_id

        elif ifselect == True and type == "insert" and need_id != "":
            num = self.db_ads.query(GroupNeedMap).filter(GroupNeedMap.ads_need_id == need_id,
                                                         GroupNeedMap.ads_group_id == group_id).count()
            if num > 0:
                self.write_json(-1, "该分组已包含need_id")
                return

            gnm = GroupNeedMap()
            gnm.ads_group_id = group_id
            gnm.ads_need_id = need_id
            gnm.create_time = datetime.datetime.now()
            self.db_ads.add(gnm)

        try:
            self.db_ads.commit()
            self.write_json(0, 'success')
        except Exception as e:
            self.db_ads.rollback()
            log.e(e)
            self.write_json(500, "更新失败")
        finally:
            self.db_ads.close()


class GroupNeedMapSelectByIdHander(SwxJsonHandler):
    def get(self, *args, **kwargs):
        groupid = self.get_argument("groupid", None)
        self.db_ads.query(GroupNeedMap).filter()
        sql = "SELECT i.anchor_level, i.need_id, i.ads_id from ads_group_need_map m  LEFT JOIN  ads_need_info  i  on i.need_id = m.ads_need_id where 1=1"
        if groupid is not None and groupid != "":
            sql = sql + " and m.ads_group_id = " + groupid + ""
        result = self.db_ads.execute(sql).fetchall()
        lst = list()
        for g in result:
            anchor_level = g[0]
            need_id = g[1]
            ads_id = g[2]
            lst.append({"anchor_level": anchor_level, "need_id": need_id, "ads_id": ads_id})
        self.write_raw_json(lst)
        self.db_ads.close()


class NeedInfoSelectById(SwxJsonHandler):
    def get(self, *args, **kwargs):
        id = self.get_argument("id", None)
        if id is not None and id != "":
            sql = "SELECT p.package_name,n.need_play_type,n. ENABLE,n.description," \
                  "n.need_name FROM	ads_need_info n LEFT JOIN ads_contract_package_info p " \
                  "ON n.package_id = p.package_id	where n.need_id=" + id

            result = self.db_ads.execute(sql).fetchall()
            lst = list()
            for g in result:
                package_name = g[0]
                need_play_type = g[1]
                enable = g[2]
                description = g[3]
                need_name = g[4]
                lst.append({"package_name": package_name, "need_play_type": need_play_type, "enable": enable,
                            "description": description, "need_name": need_name})
            self.write_raw_json(lst)
            self.db_ads.close()


####---------------白名单---------------------------------
class WhitelistInfoHanderAll(SwxJsonHandler):
    @tornado.web.authenticated
    def get(self, *args, **kwargs):
        self.render("/ads_manager/whitelist_info/whitelist_list.mako")

    @tornado.web.authenticated
    def post(self, *args, **kwargs):
        limit, args = self.get_pages_args()
        filter = args["filter"]
        id = ''
        if "search" in filter.keys():
            id = filter["search"]
        query = self.db_ads.query(AdsConfigAnchorWhitelist)
        if id:
            query = query.filter(AdsConfigAnchorWhitelist.room_id == id)
        total = query.count()
        query = query.order_by(AdsConfigAnchorWhitelist.id.desc())
        query = query.limit(int(limit['per_page'])).offset(
            (int(limit['page_index'] * 10)))
        query_result = query.all()
        # total = query.count()
        lst = list()
        for item in query_result:
            # shch_id = ''
            # if item.ads_schedule_id_list:
            #     shch_id = str(item.ads_schedule_id_list).split(',')
            lst.append({
                'id': item.id or 0,
                'plat_id': item.plat_id or 0,
                'room_id': item.room_id or '',
                'ads_schedule_id_list': item.ads_schedule_id or '',
                # 'need_id_list': item.need_id_list or '',
                'comment': item.comment or '',
                'create_time': item.create_time.isoformat() or '',
                'logtime': item.logtime.isoformat() or '',
            })
        ret = dict()
        ret['page_index'] = limit['page_index']
        ret['total'] = total
        ret['data'] = lst
        self.write_json(0, data=ret)
        self.db_ads.close()


class WhitelistAddInfoHanderAll(SwxJsonHandler):
    @tornado.web.authenticated
    @tornado.gen.coroutine
    def post(self, *args, **kwargs):

        # id = self.get_argument("id", None)
        plat_id = self.get_argument("plat_id", None)
        room_id = self.get_argument("room_id", None)
        ads_schedule_id_list = self.get_argument("ads_schedule_id_list", None)
        comment = self.get_argument("comment", None)

        args = self.get_argument('args', None)
        if args is not None:
            args = json.loads(args)
            # id = args["id"]
            plat_id = args["plat_id"]
            room_id = args["room_id"]
            ads_schedule_id_list = args["ads_schedule_id_list"]
            comment = args["comment"]
            # shch_id = 'shch_id'
            # for item in ads_schedule_id_list:
            #     shch_id = str(item) + ',' + str(shch_id)
            # shch_id = shch_id.replace(",shch_id", '')

        try:
            date_now = datetime.datetime.now()
            item = AdsConfigAnchorWhitelist(plat_id=plat_id, room_id=room_id, ads_schedule_id=ads_schedule_id_list,
                                            comment=comment,
                                            logtime=date_now, create_time=date_now
                                            )
            self.db_ads.add(item)
            self.db_ads.commit()

            self.write_json(0)  # 将上传好的路径返回
        except Exception as e:
            self.db_ads.rollback()
            log.e(e)
            self.write_json(500, "更新失败")
        finally:
            self.db_ads.close()

        self.db_ads.close()


class WhitelistDelInfoHanderAll(SwxJsonHandler):
    @tornado.web.authenticated
    def post(self, *args, **kwargs):
        args = self.get_argument('args', None)
        if args is not None:
            args = json.loads(args)
            ids = args["ids"]
        try:
            if ids:
                self.db_ads.query(AdsConfigAnchorWhitelist).filter(AdsConfigAnchorWhitelist.id.in_(ids)).delete(
                    synchronize_session=False)
                self.db_ads.commit()
                self.write_json(0, 'success')
                # self.db.close()
            else:
                self.write_json(-1, '没有选中删除项')
        except Exception as  e:
            self.db_ads.rollback()
            log.e(e)
            self.write_json(500, "删除失败")
        finally:
            self.db_ads.close()


class WhitelistEdInfoHanderAll(SwxJsonHandler):
    @tornado.web.authenticated
    @tornado.gen.coroutine
    def post(self, *args, **kwargs):

        # id = self.get_argument("id", None)
        plat_id = self.get_argument("plat_id", None)
        room_id = self.get_argument("room_id", None)
        ads_schedule_id_list = self.get_argument("ads_schedule_id_list", None)
        comment = self.get_argument("comment", None)
        shchedule_id_old = self.get_argument("shchedule_id_old", None)
        plat_id_old = self.get_argument("plat_id_old", None)
        room_id_old = self.get_argument("room_id_old", None)

        args = self.get_argument('args', None)
        if args is not None:
            args = json.loads(args)
            # id = args["id"]
            plat_id = args["plat_id"]
            room_id = args["room_id"]
            ads_schedule_id_list = args["ads_schedule_id_list"]
            comment = args["comment"]
            shchedule_id_old = args["shchedule_id_old"]
            plat_id_old = args["plat_id_old"]
            room_id_old = args["room_id_old"]

        try:
            date_now = datetime.datetime.now()
            self.db_ads.query(AdsConfigAnchorWhitelist).filter(
                and_(AdsConfigAnchorWhitelist.plat_id == plat_id_old, AdsConfigAnchorWhitelist.room_id == room_id_old,
                     AdsConfigAnchorWhitelist.ads_schedule_id == shchedule_id_old)).update(
                {AdsConfigAnchorWhitelist.plat_id: plat_id, AdsConfigAnchorWhitelist.room_id: room_id,
                 AdsConfigAnchorWhitelist.ads_schedule_id: str(ads_schedule_id_list),
                 AdsConfigAnchorWhitelist.comment: comment,
                 AdsConfigAnchorWhitelist.logtime: date_now})

            self.db_ads.commit()
            self.write_json(0)  # 将上传好的路径返回
        except Exception as e:
            self.db_ads.rollback()
            log.e(e)
            self.write_json(500, "更新失败")
        finally:
            self.db_ads.close()

        self.db_ads.close()


class WhitelistIMInfoHanderAll(SwxJsonHandler):
    @tornado.web.authenticated
    @tornado.gen.coroutine
    def post(self, *args, **kwargs):

        sql_session = None
        session_anchor = None
        upload_path = os.path.join(os.path.dirname(__file__) + '/../../..', 'UploadFiles')  # 文件的暂存路径

        # aa=os.path.dirname(os.getcwd())
        try:

            file_metas = self.request.files['infile']  # 提取表单中‘name’为‘infile’的文件元数据
            data_now_str = datetime.datetime.now().strftime('%Y%m%d%H%M%S')
            # 根据公会名，查询公会的id
            if not os.path.exists(upload_path):
                os.mkdir(upload_path)
            for meta in file_metas:
                filename = data_now_str + '(' + meta['filename'] + ')'
                filepath = os.path.join(upload_path, filename)
                with open(filepath, 'wb') as up:  # 有些文件需要已二进制的形式存储，实际中可以更改
                    up.write(meta['body'])
            # 读取文件
            workbook = xlrd.open_workbook(filepath)
            os.remove(os.path.join(upload_path, filename))
            # 拿到表名
            sheets = workbook.sheet_names()

            # 第一个表
            worksheet = workbook.sheet_by_name(sheets[0])
            # 行数
            nrows = worksheet.nrows
            if nrows <= 1:
                self.write_json(0, '上传表格错误(表格不能为空表且数据从第二行开始)')
                return
            ret = list()

            for i in range(1, worksheet.nrows):
                temp = dict()
                temp['plat_id'] = int(worksheet.cell(i, 0).value)
                temp['room_id'] = int(worksheet.cell(i, 1).value)
                temp['ads_schedule_id'] = int(worksheet.cell(i, 2).value)
                temp['comment'] = str(worksheet.cell(i, 3).value)
                # date = xldate_as_tuple(worksheet.cell(i, 4).value, 0)
                # temp['create_time'] = datetime.datetime(*date)
                query = self.db_ads.query(AdsConfigAnchorWhitelist).filter(
                    and_(AdsConfigAnchorWhitelist.plat_id == temp['plat_id'],
                         AdsConfigAnchorWhitelist.room_id == temp['room_id'],
                         AdsConfigAnchorWhitelist.ads_schedule_id == temp['ads_schedule_id'])).all()
                if query:
                    print('该次重复,room_id:' + str(temp['room_id']))
                else:
                    ret.append(temp)

            import_time = data_now_str
            for item in ret:
                item = AdsConfigAnchorWhitelist(plat_id=item['plat_id'], room_id=item['room_id'],
                                                ads_schedule_id=item['ads_schedule_id'],
                                                comment=item['comment']
                                                )

                self.db_ads.add(item)
                self.db_ads.commit()

            self.write_json(1, '上传成功')
            return
        # 认证公会审核通过（4.0）
        except Exception as e:
            # session.rollback()
            log.e('admin.roomImportAdsInfo_error:' + str(e))
            self.write_json(0, 'excel数据格式错误,error:{}'.format(e))
            return
        finally:
            if sql_session:
                sql_session.close()
            if session_anchor:
                session_anchor.close()


class seleteshchedule(SwxJsonHandler):
    def get(self, *args, **kwargs):
        id = self.get_argument("id", None)
        group_id = self.get_argument("group_id", None)
        try:
            lst = []
            ads_list = ''
            if id == '1':
                ads_list = self.db_ads.query(NeedSchedule).filter(NeedSchedule.assign_flag == '0').all()
            elif id == '0':
                if group_id:
                    ads_list = self.db_ads.query(NeedSchedule).filter(NeedSchedule.group_id == group_id).all()
                else:
                    ads_list = self.db_ads.query(NeedSchedule).all()
            # sql_session.update({AdsConfigAnchorWhitelist.eff_airtime: time_len})
            for ptype in ads_list:
                lst.append(json.loads(json.dumps(ptype, cls=AlchemyEncoder)))
            self.write_raw_json(lst)
            self.db_ads.close()
        except Exception as e:
            self.db_ads.rollback()
            log.e(e)
            self.write_json(500, "获取错误")
        finally:
            self.db_ads.close()

        self.db_ads.close()


class seleteshchedulegroup(SwxJsonHandler):
    def get(self, *args, **kwargs):
        level = self.get_argument("level", None)
        try:
            lst = []
            ads_list = ''
            if level:
                ads_list = self.db_ads.query(NeedGroupInfo).filter(NeedGroupInfo.anchor_level == level).all()
            else:
                ads_list = self.db_ads.query(NeedGroupInfo).all()
            # sql_session.update({AdsConfigAnchorWhitelist.eff_airtime: time_len})
            for ptype in ads_list:
                lst.append(json.loads(json.dumps(ptype, cls=AlchemyEncoder)))
            self.write_raw_json(lst)
            self.db_ads.close()
        except Exception as e:
            self.db_ads.rollback()
            log.e(e)
            self.write_json(500, "获取错误")
        finally:
            self.db_ads.close()

        self.db_ads.close()


####---------------黑名单---------------------------------
class BlacklistInfoHanderAll(SwxJsonHandler):
    @tornado.web.authenticated
    def get(self, *args, **kwargs):
        self.render("/ads_manager/blacklist_info/blacklist_list.mako")

    @tornado.web.authenticated
    def post(self, *args, **kwargs):
        limit, args = self.get_pages_args()
        filter = args["filter"]
        id = ''
        if "search" in filter.keys():
            id = filter["search"]
        query = self.db_ads.query(AdsConfigAnchorBlacklist)
        if id:
            query = query.filter(AdsConfigAnchorBlacklist.room_id == id)
        total = query.count()
        query = query.order_by(AdsConfigAnchorBlacklist.id.desc())
        query = query.limit(int(limit['per_page'])).offset(
            (int(limit['page_index'] * 10)))
        query_result = query.all()
        # total = query.count()
        lst = list()
        for item in query_result:
            # shch_id = ''
            # if item.ads_schedule_id:
            #     shch_id = str(item.ads_schedule_id).split(',')
            lst.append({
                'id': item.id or 0,
                'plat_id': item.plat_id or 0,
                'room_id': item.room_id or '',
                'ads_schedule_id': str(item.ads_schedule_id) or '',
                'comment': item.comment or '',
                'create_time': item.create_time.isoformat() or '',
                'logtime': item.logtime.isoformat() or '',
            })
        ret = dict()
        ret['page_index'] = limit['page_index']
        ret['total'] = total
        ret['data'] = lst
        self.write_json(0, data=ret)
        self.db_ads.close()


class BlacklistAddInfoHanderAll(SwxJsonHandler):
    @tornado.web.authenticated
    @tornado.gen.coroutine
    def post(self, *args, **kwargs):

        # id = self.get_argument("id", None)
        plat_id = self.get_argument("plat_id", None)
        room_id = self.get_argument("room_id", None)
        ads_schedule_id_list = self.get_argument("ads_schedule_id", None)
        comment = self.get_argument("comment", None)

        args = self.get_argument('args', None)
        if args is not None:
            args = json.loads(args)
            # id = args["id"]
            plat_id = args["plat_id"]
            room_id = args["room_id"]
            ads_schedule_id_list = args["ads_schedule_id"]
            comment = args["comment"]

        try:
            # date_now = datetime.datetime.now()
            item = AdsConfigAnchorBlacklist(plat_id=plat_id, room_id=room_id, ads_schedule_id=ads_schedule_id_list,
                                            comment=str(comment)
                                            )
            self.db_ads.add(item)
            self.db_ads.commit()

            self.write_json(0)  # 将上传好的路径返回
        except Exception as e:
            self.db_ads.rollback()
            log.e(e)
            self.write_json(500, "更新失败")
        finally:
            self.db_ads.close()

        self.db_ads.close()


class BlacklistDelInfoHanderAll(SwxJsonHandler):
    @tornado.web.authenticated
    def post(self, *args, **kwargs):
        args = self.get_argument('args', None)
        if args is not None:
            args = json.loads(args)
            ids = args["ids"]
        try:
            if ids:
                self.db_ads.query(AdsConfigAnchorBlacklist).filter(AdsConfigAnchorBlacklist.id.in_(ids)).delete(
                    synchronize_session=False)
                self.db_ads.commit()
                self.write_json(0, 'success')
                # self.db.close()
            else:
                self.write_json(-1, '没有选中删除项')
        except Exception as  e:
            self.db_ads.rollback()
            log.e(e)
            self.write_json(500, "删除失败")
        finally:
            self.db_ads.close()


class BlicklistEdInfoHanderAll(SwxJsonHandler):
    @tornado.web.authenticated
    @tornado.gen.coroutine
    def post(self, *args, **kwargs):

        id = self.get_argument("id", None)
        plat_id = self.get_argument("plat_id", None)
        room_id = self.get_argument("room_id", None)
        ads_schedule_id_list = self.get_argument("ads_schedule_id", None)
        comment = self.get_argument("comment", None)
        args = self.get_argument('args', None)
        if args is not None:
            args = json.loads(args)

            id = args["id"]
            plat_id = args["plat_id"]
            room_id = args["room_id"]
            ads_schedule_id_list = args["ads_schedule_id"]
            comment = args["comment"]

        try:
            date_now = datetime.datetime.now()
            self.db_ads.query(AdsConfigAnchorBlacklist).filter(AdsConfigAnchorBlacklist.id == id).update(
                {AdsConfigAnchorBlacklist.plat_id: plat_id, AdsConfigAnchorBlacklist.room_id: room_id,
                 AdsConfigAnchorBlacklist.ads_schedule_id: str(ads_schedule_id_list),
                 AdsConfigAnchorBlacklist.comment: str(comment),
                 AdsConfigAnchorBlacklist.logtime: date_now})
            # sql_session.update({AdsConfigAnchorWhitelist.eff_airtime: time_len})

            self.db_ads.commit()
            self.write_json(0)  # 将上传好的路径返回
        except Exception as e:
            self.db_ads.rollback()
            log.e(e)
            self.write_json(500, "更新失败")
        finally:
            self.db_ads.close()

        self.db_ads.close()


class BlacklistIMInfoHanderAll(SwxJsonHandler):
    @tornado.web.authenticated
    @tornado.gen.coroutine
    def post(self, *args, **kwargs):

        sql_session = None
        session_anchor = None
        upload_path = os.path.join(os.path.dirname(__file__) + '/../../..', 'UploadFiles')  # 文件的暂存路径

        # aa=os.path.dirname(os.getcwd())
        try:

            file_metas = self.request.files['infile']  # 提取表单中‘name’为‘infile’的文件元数据
            data_now_str = datetime.datetime.now().strftime('%Y%m%d%H%M%S')
            # 根据公会名，查询公会的id
            if not os.path.exists(upload_path):
                os.mkdir(upload_path)
            for meta in file_metas:
                filename = data_now_str + '(' + meta['filename'] + ')'
                filepath = os.path.join(upload_path, filename)
                with open(filepath, 'wb') as up:  # 有些文件需要已二进制的形式存储，实际中可以更改
                    up.write(meta['body'])
            # 读取文件
            workbook = xlrd.open_workbook(filepath)
            os.remove(os.path.join(upload_path, filename))
            # 拿到表名
            sheets = workbook.sheet_names()

            # 第一个表
            worksheet = workbook.sheet_by_name(sheets[0])
            # 行数
            nrows = worksheet.nrows
            if nrows <= 1:
                self.write_json(0, '上传表格错误(表格不能为空表且数据从第二行开始)')
                return
            ret = list()

            for i in range(1, worksheet.nrows):
                temp = dict()
                temp['plat_id'] = int(worksheet.cell(i, 0).value)
                temp['room_id'] = int(worksheet.cell(i, 1).value)
                temp['ads_schedule_id'] = int(worksheet.cell(i, 2).value)
                temp['comment'] = str(worksheet.cell(i, 3).value)
                # date = xldate_as_tuple(worksheet.cell(i, 4).value, 0)
                # temp['create_time'] = datetime.datetime(*date)
                query = self.db_ads.query(AdsConfigAnchorBlacklist).filter(
                    and_(AdsConfigAnchorBlacklist.plat_id == temp['plat_id'],
                         AdsConfigAnchorBlacklist.room_id == temp['room_id'],
                         AdsConfigAnchorBlacklist.ads_schedule_id == temp['ads_schedule_id'])).all()
                if query:
                    print('该次重复,room_id:' + str(temp['room_id']))
                else:
                    ret.append(temp)

            import_time = data_now_str
            for item in ret:
                item = AdsConfigAnchorBlacklist(plat_id=item['plat_id'], room_id=item['room_id'],
                                                ads_schedule_id=item['ads_schedule_id'],
                                                comment=item['comment']
                                                )

                self.db_ads.add(item)
                self.db_ads.commit()

            self.write_json(1, '上传成功')
            return
        # 认证公会审核通过（4.0）
        except Exception as e:
            # session.rollback()
            log.e('admin.roomImportAdsInfo_error:' + str(e))
            self.write_json(0, 'excel数据格式错误,请查看 url 模式 roomid 模式是否写反,error:{}'.format(e))
            return
        finally:
            if sql_session:
                sql_session.close()
            if session_anchor:
                session_anchor.close()


####---------------用户提现---------------------------------
class WithdrawanchorInfoHanderAll(SwxJsonHandler):
    @tornado.web.authenticated
    def get(self, *args, **kwargs):
        self.render("/ads_manager/withdrawanchor_info/withdrawanchor_list.mako")

    @tornado.web.authenticated
    def post(self, *args, **kwargs):
        limit, args = self.get_pages_args()

        filter = args["filter"]
        id = ''
        phone = ''
        income_from = ''
        user_id = ''
        start_time = ''
        end_time = ''
        bank_name = ''
        bank_name_list = []
        if "id" in filter.keys():
            id = filter["id"]
            phone = filter["phone"]
            income_from = filter["income_from"]
            user_id = filter["user_id"]
            start_time = filter["start_time"]
            end_time = filter["end_time"]
            bank_name = filter["bank_name"]
        query = self.db_wealth.query(TLogWithdrawAnchor)
        query_guild = self.db_guild.query(BaseUser)
        query_bank_name = self.db_wealth.query(TIdentityPersonal)
        data_now = datetime.datetime.now().strftime('%Y-%m-%d')
        if id:
            query = query.filter(TLogWithdrawAnchor.id == id)
        if phone:
            query_guild = query_guild.filter(BaseUser.u_mobile_number == phone).first()
            user_id_v2 = query_guild.user_id
            query = query.filter(TLogWithdrawAnchor.user_id == user_id_v2)
        if bank_name:
            query_bank_name = query_bank_name.filter(TIdentityPersonal.bank_name == bank_name).all()
            for item in query_bank_name:
                bank_name_list.append(item.user_id)
            query = query.filter(TLogWithdrawAnchor.user_id.in_(bank_name_list))
        if income_from:
            query = query.filter(TLogWithdrawAnchor.apply_state == income_from)
        if user_id:
            query = query.filter(TLogWithdrawAnchor.user_id == user_id)
        if start_time and end_time == None:
            query = query.filter(
                func.date_format(TLogWithdrawAnchor.create_time, '%Y-%m-%d') >= start_time)
        if end_time and start_time == None:
            query = query.filter(
                func.date_format(TLogWithdrawAnchor.create_time, '%Y-%m-%d') <= end_time)
        if start_time and end_time:
            query = query.filter(
                and_(func.date_format(TLogWithdrawAnchor.create_time, '%Y-%m-%d') <= end_time,
                     func.date_format(TLogWithdrawAnchor.create_time, '%Y-%m-%d') >= start_time))

        total = query.count()
        query = query.order_by(TLogWithdrawAnchor.id.desc()).limit(int(limit['per_page'])).offset(
            (int(limit['page_index'] * 10)))

        query_result = query.all()

        lst = list()

        for item in query_result:
            lst.append({
                'id': item.id or 0,
                'user_id': item.user_id or 0,
                'money': str(item.money) or '',
                'sevice_money': str(item.sevice_money) or '',
                'money_balance': str(item.money_balance) or '',
                'sevice_money_balance': str(item.sevice_money_balance) or '',
                'money_rp': str(item.money_rp) or '',
                'sevice_money_rp': str(item.sevice_money_rp) or '',
                'apply_state': item.apply_state or '',
                'create_time': item.create_time.isoformat() or '',
                'logtime': item.logtime.isoformat() or '',
            })
        ret = dict()
        withdraw_list = app_map().TLogWithdrawAnchor()
        guild_list = app_map().Baseuser()
        ret['page_index'] = limit['page_index']
        ret['total'] = total
        ret['data'] = lst
        for info_data in ret['data']:
            # for info_p in withdraw_list:
            if info_data['user_id'] in withdraw_list:
                info_data['id_user_name'] = withdraw_list[info_data['user_id']]['id_user_name']
                info_data['id_number'] = withdraw_list[info_data['user_id']]['id_number']
                info_data['id_img_front'] = withdraw_list[info_data['user_id']]['id_img_front']
                info_data['id_img_back'] = withdraw_list[info_data['user_id']]['id_img_back']
                info_data['bank_name'] = withdraw_list[info_data['user_id']]['bank_name']
                info_data['bank_card_number'] = withdraw_list[info_data['user_id']]['bank_card_number']
                info_data['hold_user_name'] = withdraw_list[info_data['user_id']]['hold_user_name']
                info_data['bank_sub_name'] = withdraw_list[info_data['user_id']]['bank_sub_name']
                info_data['qq_number'] = withdraw_list[info_data['user_id']]['qq_number']
            else:
                anchor_list_bank = query_bank_name.filter(TIdentityPersonal.user_id == info_data['user_id']).first()
                if anchor_list_bank:
                    info_data['id_user_name'] = anchor_list_bank.id_user_name
                    info_data['id_number'] = anchor_list_bank.id_number
                    info_data['id_img_front'] = anchor_list_bank.id_img_front
                    info_data['id_img_back'] = anchor_list_bank.id_img_back
                    info_data['bank_name'] = anchor_list_bank.bank_name
                    info_data['bank_card_number'] = anchor_list_bank.bank_card_number
                    info_data['hold_user_name'] = anchor_list_bank.hold_user_name
                    info_data['bank_sub_name'] = anchor_list_bank.bank_sub_name
                    info_data['qq_number'] = anchor_list_bank.qq_number
            if info_data['user_id'] in guild_list:
                info_data['u_mobile_number'] = guild_list[info_data['user_id']]['u_mobile_number']
            else:
                anchor_list_phone = query_guild.filter(BaseUser.user_id == info_data['user_id']).first()
                if anchor_list_phone:
                    info_data['u_mobile_number'] = anchor_list_phone.u_mobile_number

            if info_data['apply_state'] == 10:
                info_data['apply_name'] = '未处理'
            elif info_data['apply_state'] == 20:
                info_data['apply_name'] = '已提交财务'
            elif info_data['apply_state'] == 30:
                info_data['apply_name'] = '打款异常'
            elif info_data['apply_state'] == 40:
                info_data['apply_name'] = '已完成'

            if 'u_mobile_number' not in info_data:
                info_data['u_mobile_number'] = ''
            if 'id_user_name' not in info_data:
                info_data['id_user_name'] = ''
                info_data['id_number'] = ''
                info_data['id_img_front'] = ''
                info_data['id_img_back'] = ''
                info_data['bank_name'] = ''
                info_data['bank_card_number'] = ''
                info_data['hold_user_name'] = ''
                info_data['bank_sub_name'] = ''
                info_data['qq_number'] = ''
        # for item in app_map().TLogWithdrawAnchor():
        self.write_json(0, data=ret)
        self.db_wealth.close()


class WithdrawanchorUpInfoHanderAll(SwxJsonHandler):
    def get(self):
        # limit = self.get_pages_args()
        id = self.get_argument("id", None)
        phone = self.get_argument("phone", None)
        income_from = self.get_argument("income_from", None)
        user_id = self.get_argument("user_id", None)
        bank_name = self.get_argument("bank_name", None)
        start_time = self.get_argument("start_time", None)
        end_time = self.get_argument("end_time", None)
        bank_name_list = []

        query = self.db_wealth.query(TLogWithdrawAnchor)
        query_guild = self.db_guild.query(BaseUser)
        query_bank_name = self.db_wealth.query(TIdentityPersonal)
        data_now = datetime.datetime.now().strftime('%Y-%m-%d')
        if id:
            query = query.filter(TLogWithdrawAnchor.id == id)
        if phone:
            query_guild = query_guild.filter(BaseUser.u_mobile_number == phone).first()
            user_id_v2 = query_guild.user_id
            query = query.filter(TLogWithdrawAnchor.user_id == user_id_v2)
        if income_from:
            query = query.filter(TLogWithdrawAnchor.apply_state == income_from)
        if user_id:
            query = query.filter(TLogWithdrawAnchor.user_id == user_id)
        if bank_name:
            query_bank_name = query_bank_name.filter(TIdentityPersonal.bank_name == bank_name).all()
            for item in query_bank_name:
                bank_name_list.append(item.user_id)
            query = query.filter(TLogWithdrawAnchor.user_id.in_(bank_name_list))
        if start_time and end_time == None:
            query = query.filter(
                and_(func.date_format(TLogWithdrawAnchor.create_time, '%Y-%m-%d') <= data_now,
                     func.date_format(TLogWithdrawAnchor.create_time, '%Y-%m-%d') >= start_time))
        if end_time and start_time == None:
            query = query.filter(
                and_(func.date_format(TLogWithdrawAnchor.create_time, '%Y-%m-%d') <= end_time,
                     func.date_format(TLogWithdrawAnchor.create_time, '%Y-%m-%d') >= data_now))
        if start_time and end_time:
            query = query.filter(
                and_(func.date_format(TLogWithdrawAnchor.create_time, '%Y-%m-%d') <= end_time,
                     func.date_format(TLogWithdrawAnchor.create_time, '%Y-%m-%d') >= start_time))

        query_result = query.all()
        total = query.count()
        lst = list()

        for item in query_result:
            lst.append({
                'id': item.id or 0,
                'user_id': item.user_id or 0,
                'money': str(item.money) or '',
                'sevice_money': str(item.sevice_money) or '',
                'money_balance': str(item.money_balance) or '',
                'sevice_money_balance': str(item.sevice_money_balance) or '',
                'money_rp': str(item.money_rp) or '',
                'sevice_money_rp': str(item.sevice_money_rp) or '',
                'apply_state': item.apply_state or '',
                'create_time': item.create_time.isoformat() or '',
                'logtime': item.logtime.isoformat() or '',
            })
        ret = dict()
        withdraw_list = app_map().TLogWithdrawAnchor()
        guild_list = app_map().Baseuser()
        # ret['page_index'] = limit['page_index']
        ret['total'] = total
        ret['data'] = lst
        for info_data in ret['data']:
            if info_data['user_id'] in withdraw_list:
                info_data['id_user_name'] = withdraw_list[info_data['user_id']]['id_user_name']
                info_data['id_number'] = withdraw_list[info_data['user_id']]['id_number']
                info_data['id_img_front'] = withdraw_list[info_data['user_id']]['id_img_front']
                info_data['id_img_back'] = withdraw_list[info_data['user_id']]['id_img_back']
                info_data['bank_name'] = withdraw_list[info_data['user_id']]['bank_name']
                info_data['bank_card_number'] = withdraw_list[info_data['user_id']]['bank_card_number']
                info_data['hold_user_name'] = withdraw_list[info_data['user_id']]['hold_user_name']
                info_data['bank_sub_name'] = withdraw_list[info_data['user_id']]['bank_sub_name']
                info_data['qq_number'] = withdraw_list[info_data['user_id']]['qq_number']
            else:
                anchor_list_bank = query_bank_name.filter(TIdentityPersonal.user_id == info_data['user_id']).first()
                if anchor_list_bank:
                    info_data['id_user_name'] = anchor_list_bank.id_user_name
                    info_data['id_number'] = anchor_list_bank.id_number
                    info_data['id_img_front'] = anchor_list_bank.id_img_front
                    info_data['id_img_back'] = anchor_list_bank.id_img_back
                    info_data['bank_name'] = anchor_list_bank.bank_name
                    info_data['bank_card_number'] = anchor_list_bank.bank_card_number
                    info_data['hold_user_name'] = anchor_list_bank.hold_user_name
                    info_data['bank_sub_name'] = anchor_list_bank.bank_sub_name
                    info_data['qq_number'] = anchor_list_bank.qq_number

            if info_data['user_id'] in guild_list:
                info_data['u_mobile_number'] = guild_list[info_data['user_id']]['u_mobile_number']
            else:
                anchor_list_phone = query_guild.filter(BaseUser.user_id == info_data['user_id']).first()
                if anchor_list_phone:
                    info_data['u_mobile_number'] = anchor_list_phone.u_mobile_number

            if info_data['apply_state'] == 10:
                info_data['apply_name'] = '未处理'
            elif info_data['apply_state'] == 20:
                info_data['apply_name'] = '已提交财务'
            elif info_data['apply_state'] == 30:
                info_data['apply_name'] = '打款异常'
            elif info_data['apply_state'] == 40:
                info_data['apply_name'] = '已完成'

            if 'u_mobile_number' not in info_data:
                info_data['u_mobile_number'] = ''
            if 'id_user_name' not in info_data:
                info_data['id_user_name'] = ''
                info_data['id_number'] = ''
                info_data['id_img_front'] = ''
                info_data['id_img_back'] = ''
                info_data['bank_name'] = ''
                info_data['bank_card_number'] = ''
                info_data['hold_user_name'] = ''
                info_data['bank_sub_name'] = ''
                info_data['qq_number'] = ''
        # for item in app_map().TLogWithdrawAnchor():


        list_name = ['提现ID', '用户ID', '手机号', '打款金额', '服务费', '含红包金额', '申请时间', '银行名称', '银行卡号', '支行名', '持卡人姓名', '身份证号',
                     '身份证正面照片', '身份证背面照片', 'qq号', '当前余额', '状态(数据库字段对应 未处理:10,已提交财务:20,打款异常:30,已完成:40)']

        els_url = export(ret['data'], list_name, list_name)
        self.write_json(0, data=els_url)
        self.db_wealth.close()
        return


class WithdrawanchorEdInfoHanderAll(SwxJsonHandler):
    @tornado.web.authenticated
    def post(self, *args, **kwargs):
        args = self.get_argument('args', None)
        if args is not None:
            args = json.loads(args)
            ids = args["ids"]
            type = args["type"]

        try:
            date_now = datetime.datetime.now()
            if ids:
                for item in ids:
                    self.db_wealth.query(TLogWithdrawAnchor).filter(TLogWithdrawAnchor.id == item).update(
                        {TLogWithdrawAnchor.apply_state: str(type),
                         TLogWithdrawAnchor.create_time: date_now})
                    # self.db_ads.query(AdsConfigAnchorBlacklist).filter(AdsConfigAnchorBlacklist.id.in_(ids)).delete(
                    #     synchronize_session=False)
                self.db_wealth.commit()

                oplog = AdsOpLog()
                oplog.op_type = 3
                user = self.get_current_user()
                oplog.op_user_id = user["id"]
                oplog.op_user_name = user["name"]
                oplog.op_desc = '修改提现状态(批量) user_id:' + str(ids) + " 对应的apply_state:" + str(type)
                co = {"user_id": ids, "对应的apply_state": type}
                oplog.op_content = str(co)
                oplog.createtime = datetime.datetime.now()
                self.db_ads.add(oplog)
                self.db_ads.commit()

                self.write_json(0, 'success')
                self.db.close()
            else:
                self.write_json(-1, '没有选中修改项')
        except Exception as  e:
            self.db_wealth.rollback()
            log.e(e)
            self.write_json(500, "修改失败")
        finally:
            self.db_wealth.close()


class WithdrawanchorIMInfoHanderAll(SwxJsonHandler):
    @tornado.web.authenticated
    @tornado.gen.coroutine
    def post(self, *args, **kwargs):

        sql_session = None
        session_anchor = None
        upload_path = os.path.join(os.path.dirname(__file__) + '/../../..', 'UploadFiles')  # 文件的暂存路径
        # aa=os.path.dirname(os.getcwd())
        try:
            file_metas = self.request.files['infile']  # 提取表单中‘name’为‘infile’的文件元数据
            data_now_str = datetime.datetime.now().strftime('%Y%m%d%H%M%S')
            # 根据公会名，查询公会的id
            if not os.path.exists(upload_path):
                os.mkdir(upload_path)
            for meta in file_metas:
                filename = data_now_str + '(' + meta['filename'] + ')'
                filepath = os.path.join(upload_path, filename)
                with open(filepath, 'wb') as up:  # 有些文件需要已二进制的形式存储，实际中可以更改
                    up.write(meta['body'])
            # 读取文件
            workbook = xlrd.open_workbook(filepath)
            os.remove(os.path.join(upload_path, filename))
            # 拿到表名
            sheets = workbook.sheet_names()
            # 第一个表
            worksheet = workbook.sheet_by_name(sheets[0])
            # 行数
            nrows = worksheet.nrows
            if nrows <= 1:
                self.write_json(0, '上传表格错误(表格不能为空表且数据从第二行开始)')
                return
            ret = list()
            for i in range(1, worksheet.nrows):
                temp = dict()
                temp['id'] = int(worksheet.cell(i, 0).value)
                temp['apply_type'] = str(worksheet.cell(i, 16).value)
                # date = xldate_as_tuple(worksheet.cell(i, 4).value, 0)
                # temp['create_time'] = datetime.datetime(*date)
                ret.append(temp)

            import_time = data_now_str
            for item in ret:
                self.db_wealth.query(TLogWithdrawAnchor).filter(TLogWithdrawAnchor.id == item['id']).update(
                    {TLogWithdrawAnchor.apply_state: item['apply_type'],
                     TLogWithdrawAnchor.create_time: import_time})
                self.db_wealth.commit()

                oplog = AdsOpLog()
                oplog.op_type = 3
                user = self.get_current_user()
                oplog.op_user_id = user["id"]
                oplog.op_user_name = user["name"]
                oplog.op_desc = '修改提现状态(批量) id:' + str(item['id']) + " 对应的apply_state:" + str(item['apply_type'])
                co = {"user_id": item['id'], "对应的apply_state": item['apply_type']}
                oplog.op_content = str(co)
                oplog.createtime = datetime.datetime.now()
                self.db_ads.add(oplog)
                self.db_ads.commit()

            self.write_json(1, '上传修改成功')
            return
        # 认证公会审核通过（4.0）
        except Exception as e:
            # session.rollback()
            log.e('admin.roomImportAdsInfo_error:' + str(e))
            self.write_json(0, 'excel数据格式错误,error:{}'.format(e))
            return
        finally:
            if sql_session:
                sql_session.close()
            if session_anchor:
                session_anchor.close()


##-------------------------------结算---------------------------
class incomePackListHander(SwxJsonHandler):
    @tornado.web.authenticated
    def get(self, *args, **kwargs):
        self.render("/ads_manager/income/incomePack_list.mako")

    @tornado.web.authenticated
    def post(self, *args, **kwargs):
        limit, args = self.get_pages_args()
        sql = "select  package_id,package_name,begin_time,end_time,anchor_balance,union_balance,balance_last_time,status from ads_contract_package_info where 1=1"
        filter = args["filter"]
        name = ""
        if "search" in filter.keys():
            name = filter["search"]
        status = filter["status"]
        if name is not None and name != "":
            sql = sql + " and package_name like '%" + name.strip() + "%' "

        if status is not None and status != "":
            sql = sql + " and status = " + status.strip() + " "

        offset = " ORDER BY package_id DESC LIMIT {},{}".format(limit['page_index'] * 10, limit['per_page'])
        query_result = self.db_ads.execute(sql + offset).fetchall()
        count = self.db_ads.execute("select count(*) from({}) as count_data".format(sql)).scalar()
        lst = list()
        for item in query_result:
            anchor_balance = str(item[4].quantize(Decimal('0.00'))) if item[4] is not None else ""
            union_balance = str(item[5].quantize(Decimal('0.00'))) if item[5] is not None else ""
            balance_last_time = item[6].isoformat() if item[6] is not None else ""
            lst.append({
                'package_id': item[0],
                'package_name': item[1],
                'begin_time': item[2].isoformat(),
                'end_time': item[3].isoformat(),
                'anchor_balance': anchor_balance,
                'union_balance': union_balance,
                'balance_last_time': balance_last_time,
                'status': item[7],
            })
        ret = dict()
        ret['page_index'] = limit['page_index']
        ret['total'] = count
        ret['data'] = lst
        self.write_json(0, data=ret)
        self.db_ads.close()


class incomeAnchorListHander(SwxJsonHandler):
    @tornado.web.authenticated
    def get(self, *args, **kwargs):
        package_id = self.get_argument("package_id", None);
        package_name = self.get_argument("package_name", None);
        income_type = self.get_argument("type", None);
        total = self.get_argument("total", None);
        unionList = app_map().getUnionList()

        if package_id is None:
            self.write_json(-1, "系统错误")
            return
        result = self.db_wealth2.query(Paltform).all()
        lst = list()
        for r in result:
            lst.append(json.loads(json.dumps(r, cls=AlchemyEncoder)))

        self.render("/ads_manager/income/incomeAnchor_list.mako", package_id=package_id, platformList=lst,
                    package_name=package_name, income_type=income_type, unionList=unionList, total=total)

    @tornado.web.authenticated
    def post(self, *args, **kwargs):
        limit, args = self.get_pages_args()

        filter = args["filter"]

        package_id = filter["package_id"]
        income_from = filter["income_from"]
        income_type = filter["income_type"]
        plat_id = filter["plat_id"]
        union_id = filter["unionid"]
        income_log_id = filter["income_log_id"]
        user_id = filter["user_id"]
        task_id = filter["task_id"]
        room_id = filter["room_id"]
        begintime = filter["begintime"]
        endtime = filter["endtime"]

        if package_id is None or package_id == "":
            self.write_json(-1, "系统错误")
            return

        unionid2nameMap, name2unionidMap = app_map().unionid2nameMap()
        #
        # union_id = ''
        # if union_name is not None and union_name != "" and union_name in unionid2nameMap:
        #     union_id = name2unionidMap[union_name]

        # 找到套餐对应的need_id
        a = self.findNeedIdsByPackId(package_id)
        if not a:
            ret = dict()
            ret['page_index'] = limit['page_index']
            ret['total'] = 0
            ret['data'] = []
            self.write_json(0, data=ret)
            self.write_json(0, '该合同没有对应的套餐信息', ret)
            return

        sql = "select a.income_log_id,a.income_from,a.union_id,a.user_id,a.task_id,a.task_create_time," \
              "p.plat_name,a.room_id,a.logtime,a.income,a.play_id from  T_log_income_anchor a LEFT JOIN T_guild_platform p" \
              " on a.plat_id=p.plat_id where 1=1 and a.income_type={} and need_id in ({})".format(income_type,
                                                                                                  a)

        # 组装sql
        sql_list = list()
        if income_from is not None and income_from != "":
            sql_list.append(" and a.income_from like '%" + income_from.strip() + "%' ")

        if plat_id is not None and plat_id != "":
            sql_list.append(" and a.plat_id = " + plat_id.strip() + " ")

        if union_id is not None and union_id != "":
            sql_list.append(" and a.union_id = " + union_id.strip() + " ")

        if income_log_id is not None and income_log_id != "":
            sql_list.append(" and a.income_log_id like '%" + income_log_id.strip() + "%' ")

        if user_id is not None and user_id != "":
            sql_list.append(" and a.user_id like '%" + user_id.strip() + "%' ")

        if task_id is not None and task_id != "":
            sql_list.append(" and a.task_id like '%" + task_id.strip() + "%' ")

        if room_id is not None and room_id != "":
            sql_list.append(" and a.room_id like '%" + room_id.strip() + "%' ")

        if begintime is not None and begintime != "":
            sql = sql + " and a.task_create_time >= '" + begintime.strip() + "'"

        if endtime is not None and endtime != "":
            sql = sql + " and a.task_create_time <= '" + endtime.strip() + " 23:59:59 '"

        sqlStr = "".join(sql_list)
        sql = sql + sqlStr

        offset = " ORDER BY a.income_log_id DESC LIMIT {},{}".format(limit['page_index'] * 10, limit['per_page'])
        query_result = self.db_wealth2.execute(sql + offset).fetchall()
        count = self.db_wealth2.execute("select count(*) from({}) as count_data".format(sql)).scalar()
        playlogmap = app_map().getPlayLogMap()
        lst = list()
        roominfoMap = app_map().getRoomInfo()

        for item in query_result:
            income_log_id = item[0]
            income_from = item[1]
            union_id = item[2]
            union_name = ""

            if item[2] is not None and item[2] != "" and item[2] in unionid2nameMap:
                union_name = unionid2nameMap[item[2]]
            union_name = union_name
            user_id = item[3]
            task_id = item[4]
            task_create_time = item[5].isoformat()
            plat_name = item[6]
            room_id = item[7]
            anchor_name = ''
            source_link = ''
            if room_id in roominfoMap:
                anchor_name = roominfoMap[room_id]["emcee"]
                source_link = roominfoMap[room_id]["source_link"]

            logtime = item[8].isoformat()
            income = str(item[9].quantize(Decimal('0.00')))
            record_path = ''
            screen_shot_path = ''
            popularity = ''
            if item[10] in playlogmap:
                record_path = playlogmap[item[10]][1]
                screen_shot_path = playlogmap[item[10]][2]
                popularity = playlogmap[item[10]][3]
            play_id = item[10]

            lst.append({"income_log_id": income_log_id, "income_from": income_from, "record_path": record_path,
                        "union_id": union_id, "union_name": union_name, "income": income, "source_link": source_link,
                        "screen_shot_path": screen_shot_path, "play_id": play_id, "anchor_name": anchor_name,
                        "user_id": user_id, "task_id": task_id, "task_create_time": task_create_time,
                        "plat_name": plat_name, "room_id": room_id, "logtime": logtime, "popularity": popularity})

        ret = dict()
        ret['page_index'] = limit['page_index']
        ret['total'] = count
        ret['data'] = lst
        self.write_json(0, data=ret)
        self.db_wealth2.close()

    def findNeedIdsByPackId(self, package_id):
        sql_need = "SELECT need_id from  ads_need_info where package_id= {}".format(int(package_id))
        result = self.db_ads.execute(sql_need).fetchall()
        self.db_ads.close()
        a = list()
        for r in result:
            a.append(str(r[0]))
        a = ",".join(a)
        return a


####---------------广告计划查询---------------------------------
class AdvertisingPlanListHander(SwxJsonHandler):
    @tornado.web.authenticated
    def get(self, *args, **kwargs):
        self.render("/ads_manager/advertising_plan_info/advertising_plan_list.mako")

    @tornado.web.authenticated
    def post(self, *args, **kwargs):
        limit, args = self.get_pages_args()

        filter = args["filter"]
        level = ''
        schedule_id = ''
        plan_status = ''
        date = ''
        if "level" in filter.keys():
            level = filter["level"]
            schedule_id = filter["schedule_id"]
            plan_status = filter["plan_status"]
            date = filter["date"]
        query = self.db_entourage.query(AdsNeedPlanInfo)
        data_now = datetime.datetime.now().strftime('%Y-%m-%d')
        if level:
            query = query.filter(AdsNeedPlanInfo.anchor_level == level)
        if schedule_id:
            query = query.filter(AdsNeedPlanInfo.schedule_id == schedule_id)
        if date:
            query = query.filter(AdsNeedPlanInfo.play_time == date)
        else:
            query = query.filter(AdsNeedPlanInfo.play_time == data_now)
        if plan_status == '1':
            query = query.filter(or_(AdsNeedPlanInfo.plan_status == 1, AdsNeedPlanInfo.plan_status == 0))
        elif plan_status:
            query = query.filter(AdsNeedPlanInfo.plan_status == plan_status)

        total = query.count()
        query = query.order_by(AdsNeedPlanInfo.need_plan_id.desc())
        query = query.limit(int(limit['per_page'])).offset(
            (int(limit['page_index'] * 10)))
        # if id:
        #     query = query.filter(AdsNeedPlanInfo.id == id)
        #
        # if income_from:
        #     query = query.filter(AdsNeedPlanInfo.apply_state == income_from)
        # if user_id:
        #     query = query.filter(AdsNeedPlanInfo.user_id == user_id)

        query_result = query.all()

        lst = list()
        for item in query_result:
            lst.append({
                'need_plan_id': item.need_plan_id or 0,
                'task_id': item.task_id or 0,
                'plan_status': item.plan_status or 0,
                'schedule_id': item.schedule_id or '',
                'group_id': item.group_id or '',
                'flag': item.flag,
                'anchor_level': item.anchor_level or '',
                'create_time': item.create_time.isoformat() or '',
                'logtime': item.logtime.isoformat() or '',
                'play_time': str(item.play_time) or '',
            })

        ret = dict()
        ret['page_index'] = limit['page_index']
        ret['total'] = total
        ret['data'] = lst

        for info_data in ret['data']:
            if info_data['plan_status'] == 0:
                info_data['plan_name'] = '未接'
            elif info_data['plan_status'] == 1:
                info_data['plan_name'] = '未接'
            elif info_data['plan_status'] == 2:
                info_data['plan_name'] = '已接'
            elif info_data['plan_status'] == 5:
                info_data['plan_name'] = '完成'
        # for item in app_map().TLogWithdrawAnchor():
        self.write_json(0, data=ret)
        self.db_wealth.close()


class seleteshcheduleadvertisting(SwxJsonHandler):
    def get(self, *args, **kwargs):
        level = self.get_argument("level", None)
        #
        try:
            lst = []
            query_schedule = ''
            if level:
                query = self.db_entourage.query(distinct(AdsNeedPlanInfo.schedule_id),
                                                NeedSchedule.description).join(NeedSchedule,
                                                                               NeedSchedule.schedule_id == AdsNeedPlanInfo.schedule_id).filter(
                    and_(AdsNeedPlanInfo.anchor_level == level, NeedSchedule.enable == 1)).order_by(
                    AdsNeedPlanInfo.schedule_id.desc())
            else:
                query = self.db_entourage.query(distinct(AdsNeedPlanInfo.schedule_id),
                                                NeedSchedule.description).join(NeedSchedule,
                                                                               NeedSchedule.schedule_id == AdsNeedPlanInfo.schedule_id).filter(
                    NeedSchedule.enable == 1).order_by(
                    AdsNeedPlanInfo.schedule_id.desc())

            query_schedule = query.all()
            # sql_session.update({AdsConfigAnchorWhitelist.eff_airtime: time_len})
            for ptype in query_schedule:
                lst.append(json.loads(json.dumps(ptype, cls=AlchemyEncoder)))
            self.write_raw_json(lst)
            self.db_entourage.close()
        except Exception as e:
            self.db_entourage.rollback()
            log.e(e)
            self.write_json(500, "获取错误")
        finally:
            self.db_entourage.close()

        self.db_entourage.close()


class getRoomInfoHander(SwxJsonHandler):
    def get(self, *args, **kwargs):
        roomInfoMap = app_map().getRoomInfo()
        roomId = self.get_argument("roomId", None)
        if roomId in roomInfoMap:
            self.write_json(0, 'succeed', roomInfoMap[roomId])
        else:
            self.write_json(-1, '找不到对应的房间信息')


class incomeAnchorExportHander(SwxJsonHandler):
    @tornado.web.authenticated
    def get(self, *args, **kwargs):
        # limit, args = self.get_pages_args()
        #
        # filter = args["filter"]
        filename = ''
        package_id = self.get_argument("package_id", None)
        package_name = self.get_argument("package_name", None)
        income_from = self.get_argument("income_from", None)
        plat_id = self.get_argument("plat_id", None)
        income_type = self.get_argument("income_type", None)
        union_id = self.get_argument("union_id", None)
        income_log_id = self.get_argument("income_log_id", None)
        user_id = self.get_argument("user_id", None)
        task_id = self.get_argument("task_id", None)
        room_id = self.get_argument("room_id", None)

        if package_id is None or package_id == "":
            self.write_json(-1, "系统错误")
            return

        unionid2nameMap, name2unionidMap = app_map().unionid2nameMap()
        roomInfoMap = app_map().getRoomInfo()

        # if union_name is not None and union_name != "" and union_name in unionid2nameMap:
        #     union_id = name2unionidMap[union_name]

        # 找到套餐对应的need_id
        a = self.findNeedIdsByPackId(package_id)
        if not a:
            self.write_json(-1, "没有数据")
            return

        sql = "select a.income_log_id,a.income_from,a.union_id,a.user_id,a.task_id,a.task_create_time," \
              "p.plat_name,a.room_id,a.logtime,a.income from  T_log_income_anchor a LEFT JOIN T_guild_platform p on a.plat_id=p.plat_id where a.income_type={} and need_id in ({})".format(
            income_type, a)

        if package_name:
            filename += "套餐名:" + package_name

        # 组装sql
        sql_list = list()
        if income_from is not None and income_from != "":
            sql_list.append(" and a.income_from like '%" + income_from.strip() + "%' ")

        if plat_id is not None and plat_id != "":
            sql_list.append(" and a.plat_id = " + plat_id.strip() + " ")

        if union_id is not None and union_id != "":
            sql_list.append(" and a.union_id = " + union_id.strip() + " ")

        if income_log_id is not None and income_log_id != "":
            sql_list.append(" and a.income_log_id like '%" + income_log_id.strip() + "%' ")

        if user_id is not None and user_id != "":
            sql_list.append(" and a.user_id like '%" + user_id.strip() + "%' ")

        if task_id is not None and task_id != "":
            sql_list.append(" and a.task_id like '%" + task_id.strip() + "%' ")

        if room_id is not None and room_id != "":
            sql_list.append(" and a.room_id like '%" + room_id.strip() + "%' ")

        sqlStr = "".join(sql_list)
        sql = sql + sqlStr

        offset = " ORDER BY logtime DESC"
        query_result = self.db_wealth.execute(sql + offset).fetchall()
        # count = self.db_wealth.execute("select count(*) from({}) as count_data".format(sql)).scalar()
        lst = list()
        for item in query_result:
            income_log_id = item[0]
            income_from = "自然结算" if item[1] == 1 else ("人工结算" if item[1] == 2 else "")
            union_id = item[2]
            union_name = ""

            if item[2] is not None and item[2] != "" and item[2] in unionid2nameMap:
                union_name = unionid2nameMap[item[2]]
            union_name = union_name
            user_id = item[3]
            task_id = item[4]
            task_create_time = item[5].isoformat()
            if task_create_time is not None:
                task_create_time = task_create_time.replace("T", " ")
            plat_name = item[6]
            room_id = item[7]
            anchor_name = ''
            room_url = ''
            if room_id is not None and room_id in roomInfoMap:
                anchor_name = roomInfoMap[room_id]["emcee"]
                room_url = roomInfoMap[room_id]["source_link"]
            logtime = item[8].isoformat()
            income = str(item[9].quantize(Decimal('0.00')))
            lst.append({"income_log_id": income_log_id, "income_from": income_from,
                        "union_id": union_id, "union_name": union_name, "income": income,
                        "user_id": user_id, "task_id": task_id, "task_create_time": task_create_time,
                        "room_url": room_url,
                        "plat_name": plat_name, "room_id": room_id, "logtime": logtime, "anchor_name": anchor_name})
        self.db_wealth.close()

        list_name = ['结算工会id', '结算工会名称', '结算id', '结算逻辑', '结算金额', '用户id', '任务id', '任务日期', '平台', '房间id', '主播名称', '房间地址']
        els_url = exportIncome(lst, list_name, filename)
        self.write_json(0, data=els_url)
        return

    def findNeedIdsByPackId(self, package_id):
        sql_need = "SELECT need_id from  ads_need_info where package_id= {}".format(int(package_id))
        result = self.db_ads.execute(sql_need).fetchall()
        self.db_ads.close()
        a = list()
        for r in result:
            a.append(str(r[0]))
        a = ",".join(a)
        return a


class PlayRecordHander(SwxJsonHandler):
    @tornado.web.authenticated
    def get(self, *args, **kwargs):
        self.render("/ads_manager/playRecord/playRecord_list.mako")

    @tornado.web.authenticated
    def post(self, *args, **kwargs):

        limit, args = self.get_pages_args()

        sql = "SELECT p.play_id,p.user_id,t.room_id,p.popularity,p.popularity_from,p.income," \
              "p.record_path,p.screen_shot_path,p.verify_status,p.verify_result,p.logtime,p.create_time,p.status,p.need_id,p.begin_time " \
              "from ads_task_play_log p FORCE INDEX(idx_task_id) LEFT JOIN ads_task t on p.task_id=t.task_id where 1=1"

        filter = args["filter"]
        room_id = filter["room_id"]
        user_id = filter["user_id"]
        status = filter["status"]
        verify_status = filter["verify_status"]
        begintime = filter["begintime"]
        verify_result = filter["verify_result"]
        # endtime = filter["endtime"]

        sql_count = "select "
        if user_id is not None and user_id != "":
            sql = sql + " and p.user_id like '%" + user_id.strip() + "%'"
        if room_id is not None and room_id != "":
            sql = sql + " and t.room_id like '%" + room_id.strip() + "%'"

        if verify_status is not None and verify_status != "":
            sql = sql + " and p.verify_status = '" + verify_status.strip() + "'"
        if verify_result is not None and verify_result != "":
            if (verify_result == '0' or verify_result == '-1'):
                sql = sql + " and p.verify_result = '" + verify_result.strip() + "'"
            else:
                sql = sql + " and p.verify_result != '0'"
                sql = sql + " and p.verify_result != '-1'"

        if begintime is not None and begintime != "":
            sql = sql + " and p.create_time = '" + begintime.strip() + "'"
        # else:
        #     sql = sql + " and p.create_time = '" + str(datetime.date.today()) + "'"

        # if endtime is not None and endtime != "":
        #     sql = sql + " and p.create_time <= '" + endtime.strip() + " 23:59:59 '"
        if status is not None and status != "":
            if status == '3':
                sql = sql + " and (p.status = 1 or p.status=2)"
            else:
                sql = sql + " and p.status = '" + status.strip() + "'"

        offset = " ORDER BY p.play_id DESC LIMIT {},{}".format(limit['page_index'] * 10, limit['per_page'])
        datas = self.db_ads.execute(sql + offset).fetchall()
        roominfoMap = app_map().getRoomInfo()
        lst = list()
        for data in datas:
            play_id = data[0]
            user_id = data[1]
            room_id = data[2]
            source_link = ''
            if room_id in roominfoMap:
                source_link = roominfoMap[room_id]["source_link"]

            popularity = data[3]
            popularity_from = data[4]
            income = str(data[5].quantize(Decimal('0.00'))) if data[5] is not None else ""
            record_path = data[6]
            screen_shot_path = data[7]
            verify_status = data[8]
            verify_result = data[9]
            logtime = data[10].isoformat()
            create_time = data[11].isoformat()
            status = data[12]
            need_id = data[13]
            begin_time = data[14].isoformat()
            lst.append(
                {"play_id": play_id, "need_id": need_id, "user_id": user_id, "room_id": room_id,
                 "source_link": source_link,
                 "popularity": popularity, "verify_result": verify_result, "begin_time": begin_time,
                 "popularity_from": popularity_from, "income": income, "screen_shot_path": screen_shot_path,
                 "verify_status": verify_status,
                 "logtime": logtime, "record_path": record_path, "create_time": create_time, "status": status})

        count = self.db_ads.execute("select count(*) from({}) as count_data".format(sql)).scalar()
        ret = dict()
        ret['page_index'] = limit['page_index']
        ret['total'] = count
        ret['data'] = lst
        self.write_json(0, data=ret)
        self.db_ads.close()
class PlayRecordReadHander(SwxJsonHandler):
    @tornado.web.authenticated
    def get(self, *args, **kwargs):
        self.render("/ads_manager/playRecordRead/playRecord_list.mako")

    @tornado.web.authenticated
    def post(self, *args, **kwargs):

        limit, args = self.get_pages_args()

        sql = "SELECT p.play_id,p.user_id,t.room_id,p.popularity,p.popularity_from,p.income," \
              "p.record_path,p.screen_shot_path,p.verify_status,p.verify_result,p.logtime,p.create_time,p.status,p.need_id,p.begin_time " \
              "from ads_task_play_log p FORCE INDEX(idx_task_id) LEFT JOIN ads_task t on p.task_id=t.task_id where 1=1"

        filter = args["filter"]
        room_id = filter["room_id"]
        user_id = filter["user_id"]
        status = filter["status"]
        verify_status = filter["verify_status"]
        begintime = filter["begintime"]
        verify_result = filter["verify_result"]
        # endtime = filter["endtime"]

        sql_count = "select "
        if user_id is not None and user_id != "":
            sql = sql + " and p.user_id like '%" + user_id.strip() + "%'"
        if room_id is not None and room_id != "":
            sql = sql + " and t.room_id like '%" + room_id.strip() + "%'"

        if verify_status is not None and verify_status != "":
            sql = sql + " and p.verify_status = '" + verify_status.strip() + "'"
        if verify_result is not None and verify_result != "":
            if (verify_result == '0' or verify_result == '-1'):
                sql = sql + " and p.verify_result = '" + verify_result.strip() + "'"
            else:
                sql = sql + " and p.verify_result != '0'"
                sql = sql + " and p.verify_result != '-1'"

        if begintime is not None and begintime != "":
            sql = sql + " and p.create_time = '" + begintime.strip() + "'"
        # else:
        #     sql = sql + " and p.create_time = '" + str(datetime.date.today()) + "'"

        # if endtime is not None and endtime != "":
        #     sql = sql + " and p.create_time <= '" + endtime.strip() + " 23:59:59 '"
        if status is not None and status != "":
            if status=='3':
                sql = sql + " and (p.status = 1 or p.status=2)"
            else:
                sql = sql + " and p.status = '" + status.strip() + "'"

        offset = " ORDER BY p.play_id DESC LIMIT {},{}".format(limit['page_index'] * 10, limit['per_page'])
        datas = self.db_ads.execute(sql + offset).fetchall()
        roominfoMap = app_map().getRoomInfo()
        lst = list()
        for data in datas:
            play_id = data[0]
            user_id = data[1]
            room_id = data[2]
            source_link = ''
            if room_id in roominfoMap:
                source_link = roominfoMap[room_id]["source_link"]

            popularity = data[3]
            popularity_from = data[4]
            income = str(data[5].quantize(Decimal('0.00'))) if data[5] is not None else ""
            record_path = data[6]
            screen_shot_path = data[7]
            verify_status = data[8]
            verify_result = data[9]
            logtime = data[10].isoformat()
            create_time = data[11].isoformat()
            status = data[12]
            need_id = data[13]
            begin_time = data[14].isoformat()
            lst.append(
                {"play_id": play_id, "need_id": need_id, "user_id": user_id, "room_id": room_id,
                 "source_link": source_link,
                 "popularity": popularity, "verify_result": verify_result, "begin_time": begin_time,
                 "popularity_from": popularity_from, "income": income, "screen_shot_path": screen_shot_path,
                 "verify_status": verify_status,
                 "logtime": logtime, "record_path": record_path, "create_time": create_time, "status": status})

        count = self.db_ads.execute("select count(*) from({}) as count_data".format(sql)).scalar()
        ret = dict()
        ret['page_index'] = limit['page_index']
        ret['total'] = count
        ret['data'] = lst
        self.write_json(0, data=ret)
        self.db_ads.close()


class playRecordAuditHander(SwxJsonHandler):
    def post(self):
        args = self.get_argument('args', None)
        if args is not None:
            args = json.loads(args)
        id = args["id"]
        verify_result = args["verify_result"]
        user = self.get_current_user()
        v_data = self.db_ads.query(TaskPlayLog).filter(TaskPlayLog.play_id == id).first()
        v_data.verify_status = 1
        v_data.verify_result = verify_result
        v_data.verify_user = user["id"]

        oplog = AdsOpLog()
        oplog.op_type = 4
        oplog.op_user_id = user["id"]
        oplog.op_user_name = user["name"]
        oplog.op_desc = '审核播放记录 play_id:' + str(id) + "  verify_result:" + str(verify_result)
        co = {"play_id": id, "verify_result": verify_result}
        oplog.op_content = str(co)
        oplog.createtime = datetime.datetime.now()
        self.db_ads.add(oplog)

        try:
            self.db_ads.commit()
            self.write_json(0)
        except Exception as e:
            self.db_ads.rollback()
            log.e(e)
            self.write_json(500, "审核失败")
        finally:
            self.db_ads.close()


class playRecordEditHander(SwxJsonHandler):
    def post(self):
        args = self.get_argument('args', None)
        if args is not None:
            args = json.loads(args)
        income = args["income"]
        play_id = args["play_id"]
        v_data = self.db_ads.query(TaskPlayLog).filter(TaskPlayLog.play_id == play_id).first()
        v_data.income = income

        oplog = AdsOpLog()
        oplog.op_type = 2
        user = self.get_current_user()
        oplog.op_user_id = user["id"]
        oplog.op_user_name = user["name"]
        oplog.op_desc = '修改播放金额 play_id:' + str(play_id) + " income:" + str(income)
        co = {"play_id": play_id, "income": income}
        oplog.op_content = str(co)
        oplog.createtime = datetime.datetime.now()
        self.db_ads.add(oplog)

        try:
            self.db_ads.commit()
            self.write_json(0)
        except Exception as e:
            self.db_ads.rollback()
            log.e(e)
            self.write_json(500, "补贴操作失败")
        finally:
            self.db_ads.close()


class needinfoBatchAddHander(SwxJsonHandler):
    @tornado.web.authenticated
    def get(self, *args, **kwargs):
        self.render("/ads_manager/need_info/needinfo_create.mako")

    @tornado.web.authenticated
    def post(self, *args, **kwargs):
        param = self.get_argument("param")
        ifrepait = self.get_argument("ifrepait")
        package_name = self.get_argument("package_name")

        if ifrepait == '1':
            pi = PackageInfo()
            pi.package_name = package_name
            pi.anchor_alloc_type = 2
            pi.comment = package_name
            pi.create_time = datetime.datetime.now()
            self.db_ads.add(pi)
            try:
                self.db_ads.commit()
            except Exception as e:
                self.db_ads.rollback()
                log.e(e)
                self.write_json(500, "添加失败")
                self.db_ads.close()
                return

        if param is not None:
            param = json.loads(param)
            for p in param:
                ads_id = p["ads_id"]
                position = p["position"]
                description = p["description"]
                package_id = p["package_id"]
                need_name = p["need_name"]
                need_play_type = p["need_play_type"]
                anchor_level = p["anchor_level"]
                enable = p["enable"]

                self.db_ads.begin_nested()
                try:
                    ngp = NeedGroupInfo()
                    ngp.group_name = need_name
                    ngp.comment = need_name
                    ngp.anchor_level = anchor_level
                    self.db_ads.add(ngp)
                    try:
                        self.db_ads.commit()
                    except Exception as e:
                        self.db_ads.rollback()
                        log.e(e)
                        self.write_json(500, "添加失败")
                        self.db_ads.close()
                        return

                    ni = NeedInfo()
                    ni.ads_id = ads_id
                    ni.position = position
                    ni.position_count = len(position.split(",")) if position is not None else 0
                    ni.description = description
                    ni.package_id = package_id
                    ni.need_play_type = need_play_type
                    ni.need_name = need_name
                    ni.anchor_level = anchor_level
                    # ni.ads_need_group_id=ngp.ads_need_group_id
                    ni.enable = enable
                    self.db_ads.add(ni)
                    try:
                        self.db_ads.commit()
                    except Exception as e:
                        self.db_ads.rollback()
                        log.e(e)
                        self.write_json(500, "添加失败")
                        self.db_ads.close()
                        return

                    if ifrepait == '1':
                        pnm = PackageNeedMap()
                        pnm.ads_package_id = pi.ads_package_id
                        pnm.ads_need_id = ni.need_id
                        pnm.description = ni.description
                        pnm.create_time = datetime.datetime.now()
                        self.db_ads.add(pnm)
                        try:
                            self.db_ads.commit()
                        except Exception as e:
                            self.db_ads.rollback()
                            self.db_ads.close()
                            log.e(e)
                            self.write_json(500, "添加失败")
                            return

                    gnm = GroupNeedMap()
                    gnm.ads_group_id = ngp.ads_need_group_id
                    gnm.ads_need_id = ni.need_id
                    gnm.description = need_name
                    gnm.create_time = datetime.datetime.now()
                    self.db_ads.add(gnm)

                    try:
                        self.db_ads.commit()
                    except Exception as e:
                        self.db_ads.rollback()
                        log.e(e)
                        self.write_json(500, "添加失败")
                        return
                    finally:
                        self.db_ads.close()
                    self.db_ads.commit()
                except Exception as e:
                    self.db_ads.rollback()
                    log.e(e)
                    self.write_json(500, "添加失败")
            self.write_json(0)
        else:
            self.write_json(-1, "没有需要添加的schedule数据")


class incomeAnchorsettleHander(SwxJsonHandler):
    @tornado.web.authenticated
    def post(self, *args, **kwargs):
        args = self.get_argument("args")
        if args is not None:
            args = json.loads(args)
        package_id = args["package_id"]
        type = ''
        if "type" in args:
            type = args["type"]
        result = self.db_ads.query(NeedInfo).filter(NeedInfo.package_id == package_id).all()
        lst = list()
        for ret in result:
            lst.append(str(ret.need_id))
        lst = ",".join(lst)
        sql = "select income ,income_type from T_log_income_anchor where need_id in ({})".format(lst)
        result_income = self.db_wealth.execute(sql).fetchall()

        self.db_wealth.close()

        anchor_income = 0
        union_inmome = 0

        for ret in result_income:
            if ret[1] == 1:
                anchor_income += ret[0]
            elif ret[1] == 2:
                union_inmome += ret[0]

        v_data = self.db_ads.query(ContractPackInfo).filter(ContractPackInfo.package_id == package_id).first()
        v_data.anchor_balance = anchor_income
        v_data.union_balance = union_inmome
        if type == "1":
            v_data.status = 2
        v_data.balance_last_time = datetime.datetime.now()
        try:
            self.db_ads.commit()
            self.write_json(0)
        except Exception as e:
            self.db_ads.rollback()
            log.e(e)
            self.write_json(500, "添加失败")
        finally:
            self.db_ads.close()


####---------------log查询---------------------------------
class LogSelectInfoListHander(SwxJsonHandler):
    @tornado.web.authenticated
    def get(self, *args, **kwargs):
        self.render("/ads_manager/logselect_info/logselect_list.mako")

    @tornado.web.authenticated
    def post(self, *args, **kwargs):
        limit, args = self.get_pages_args()

        filter = args["filter"]
        op_type = ''
        op_user_name = ''
        start_time = ''
        end_time = ''
        if "level" in filter.keys():
            op_type = filter["level"]
            op_user_name = filter["user_id"]
            start_time = filter["start_time"]
            end_time = filter["end_time"]
        query = self.db_ads.query(AdsOpLog)
        data_now = datetime.datetime.now().strftime('%Y-%m-%d')
        if op_type:
            query = query.filter(AdsOpLog.op_type == op_type)
        if op_user_name:
            op_user_name = '%' + op_user_name + '%'
            query = query.filter(AdsOpLog.op_user_name.like(op_user_name))
        if start_time and end_time == None:
            query = query.filter(
                and_(func.date_format(AdsOpLog.createtime, '%Y-%m-%d') <= data_now,
                     func.date_format(AdsOpLog.createtime, '%Y-%m-%d') >= start_time))
        if end_time and start_time == None:
            query = query.filter(
                and_(func.date_format(AdsOpLog.createtime, '%Y-%m-%d') <= end_time,
                     func.date_format(AdsOpLog.createtime, '%Y-%m-%d') >= data_now))
        if start_time and end_time:
            query = query.filter(
                and_(func.date_format(AdsOpLog.createtime, '%Y-%m-%d') <= end_time,
                     func.date_format(AdsOpLog.createtime, '%Y-%m-%d') >= start_time))

        total = query.count()
        query = query.order_by(AdsOpLog.op_id.desc())
        query = query.limit(int(limit['per_page'])).offset(
            (int(limit['page_index'] * 10)))

        query_result = query.all()

        lst = list()
        for item in query_result:
            lst.append({
                'op_id': item.op_id or 0,
                'op_type': item.op_type or 0,
                'op_user_id': item.op_user_id or 0,
                'op_user_name': item.op_user_name or '',
                'op_desc': item.op_desc or '',
                'op_content': item.op_content,
                'create_time': item.createtime.isoformat() or '',
            })

        ret = dict()
        ret['page_index'] = limit['page_index']
        ret['total'] = total
        ret['data'] = lst

        for info_data in ret['data']:
            if info_data['op_type'] == 1:
                info_data['op_name'] = '撤回广告'
            if info_data['op_type'] == 2:
                info_data['op_name'] = '补贴金额'
            if info_data['op_type'] == 3:
                info_data['op_name'] = '提现修改'
            if info_data['op_type'] == 4:
                info_data['op_name'] = '审核记录'
            if info_data['op_type'] == 5:
                info_data['op_name'] = '广告投放'
            if info_data['op_type'] == 6:
                info_data['op_name'] = '自动化审核'

        # for item in app_map().TLogWithdrawAnchor():
        self.write_json(0, data=ret)
        self.db_wealth.close()


class LogSelectInfoListHander_content(SwxJsonHandler):
    def get(self, *args, **kwargs):
        id = self.get_argument("id", None)
        datas = self.db_ads.query(AdsOpLog.op_content).filter(AdsOpLog.op_id == id).first()
        lst = {}
        list_s = []
        if datas:
            op_content = datas[0]
            # op_content = json.dumps(op_content)
            op_content = re.sub('\'', '\"', op_content)
            op_cc = json.loads(op_content)

            for item in op_cc.keys():
                list_s.append(item)
            if op_content:
                lst['id_id'] = op_cc[str(list_s[0])]
                lst['id_name'] = str(list_s[0])
                lst['apply_state'] = str(op_cc[str(list_s[1])])
                lst['apply_name'] = str(list_s[1])
            else:
                self.write_json(-1, '没有对应的描述')
                self.db_ads.close()
                return
        else:
            self.write_json(-1, '没有对应的套餐数据')
            self.db_ads.close()
            return
        self.write_json(0, '', lst)
        self.db_ads.close()


class Paltform4AllList(SwxJsonHandler):
    @tornado.web.authenticated
    def get(self):
        unionList = app_map().getUnionList()
        self.write_raw_json(unionList)


class fulshDateHander(SwxJsonHandler):
    @tornado.web.authenticated
    def get(self, *args, **kwargs):
        try:
            response1 = request.urlopen(
                r"http://120.92.116.187:12001/base_data/flush?access_token=bfb19b31c3a3f74c92c0cea48db05fda5ffd9088")
            if response1 is not None:
                ret = response1.read().decode('utf-8')
                data = json.loads(ret)
                if data["Code"] == 0:
                    response2 = request.urlopen(
                        r"http://120.92.116.187:12001/plan_info/flush?access_token=bfb19b31c3a3f74c92c0cea48db05fda5ffd9088")
                    if response2 is not None:
                        ret = response2.read().decode('utf-8')
                        data2 = json.loads(ret)
                        if data2["Code"] == 0:
                            self.write_json(0)
                        else:
                            self.write_json(-1, '刷新失败')
                else:
                    self.write_json(-1, "刷新失败")
            else:
                self.write_json(-1, "刷新失败")
        except Exception as e:
            log.e(e)
            self.write_json(-1, "刷新失败")


class playRecordImportHanderAll(SwxJsonHandler):
    @tornado.web.authenticated
    @tornado.gen.coroutine
    def post(self, *args, **kwargs):
        upload_path = os.path.join(os.path.dirname(__file__) + '/../../..', 'UploadFiles')  # 文件的暂存路径

        file_metas = self.request.files['infile']  # 提取表单中‘name’为‘infile’的文件元数据
        playnum = self.get_argument("playnum", None)
        data_now_str = datetime.datetime.now().strftime('%Y%m%d%H%M%S')
        # 根据公会名，查询公会的id
        if not os.path.exists(upload_path):
            os.mkdir(upload_path)
        for meta in file_metas:
            filename = data_now_str + '(' + meta['filename'] + ')'
            filepath = os.path.join(upload_path, filename)
            with open(filepath, 'wb') as up:  # 有些文件需要已二进制的形式存储，实际中可以更改
                up.write(meta['body'])
        # 读取文件
        workbook = xlrd.open_workbook(filepath)
        os.remove(os.path.join(upload_path, filename))
        # 拿到表名
        sheets = workbook.sheet_names()
        # 第一个表
        worksheet = workbook.sheet_by_name(sheets[0])
        # 行数
        nrows = worksheet.nrows
        if nrows <= 1:
            self.write_json(0, '上传表格错误(表格不能为空表且数据从第二行开始)')
            return

        lst = list()

        for i in range(1, worksheet.nrows):
            if worksheet.ncols != 20:
                lst.append("第" + str(i) + "行数据列数不对\n")
            if worksheet.cell(i, 12).value != 'None' and worksheet.cell(i, 12).value != '':
                if not self.isNum(worksheet.cell(i, 12).value):
                    lst.append("第" + str(i+1) + "行 第M列 数据格式不对")
            if worksheet.cell(i, 14).value != 'None' and worksheet.cell(i, 12).value != '':
                if not self.isNum(worksheet.cell(i, 14).value):
                    lst.append("第" + str(i+1) + "行 第O列 数据格式不对")
            if worksheet.cell(i, 15).value != 'None' and worksheet.cell(i, 12).value != '':
                if not self.isNum(worksheet.cell(i, 15).value):
                    lst.append("第" + str(i+1) + "行 第P列 数据格式不对")
            if worksheet.cell(i, 16).value != 'None' and worksheet.cell(i, 12).value != '':
                if not self.isNum(worksheet.cell(i, 16).value):
                    lst.append("第" + str(i+1) + "行 第Q列 数据格式不对")

        if lst:
            error = ','.join(lst)
            self.write_json(-1, error)
            return error

        try:
            yield self.importExcelData(nrows, playnum, worksheet)
            self.write_json(0, '上传成功')
        except Exception as e:
            self.db_ads.rollback()
            log.e('ads_task_play_log excel import error:{}'.format(e))
            self.write_json(-1, 'excel数据格式错误,error:{}'.format(e))
            return
        finally:
            self.db_ads.close()

    def isNum(self,value):
        try:
            float(value)
        except Exception:
            return False
        else:
            return True

    @run_on_executor
    def importExcelData(self, nrows, playnum, worksheet):
        for i in range(1, worksheet.nrows):
            ##更新当前进度
            app_playlog[int(playnum)] = {"now": i, "max": nrows}
            # time.sleep(3)
            temp = dict()
            temp['popularity'] = int(worksheet.cell(i, 12).value) if worksheet.cell(i,
                                                                                    12).value != 'None' and worksheet.cell(
                i, 12).value != '' else 0
            temp['play_id'] = int(worksheet.cell(i, 14).value) if worksheet.cell(i,
                                                                                 14).value != 'None' and worksheet.cell(
                i, 14).value != '' else 0
            temp['income'] = '{:g}'.format(float(worksheet.cell(i, 15).value)) if worksheet.cell(i,
                                                                                                 15).value != 'None' and worksheet.cell(
                i, 15).value != '' else 0
            temp['verify_result'] = int(worksheet.cell(i, 16).value) if worksheet.cell(i,
                                                                                       16).value != 'None' and worksheet.cell(
                i, 16).value != '' else 0
            query = self.db_ads.query(TaskPlayLog).filter(
                and_(TaskPlayLog.popularity == temp['popularity'],
                     TaskPlayLog.income == temp['income'],
                     TaskPlayLog.verify_result == temp['verify_result'],
                     TaskPlayLog.play_id == temp['play_id'])).all()
            if query:
                log.v('该次重复,play_id:' + str(temp['play_id']))
            else:
                user = self.get_current_user()

                v_data = self.db_ads.query(TaskPlayLog).filter(TaskPlayLog.play_id == temp['play_id']).first()
                if v_data:
                    v_data.popularity = temp['popularity']
                    v_data.income = temp['income']
                    v_data.verify_result = temp['verify_result']
                    v_data.verify_user = user["id"]

                    oplog = AdsOpLog()
                    oplog.op_type = 4
                    oplog.op_user_id = user["id"]
                    oplog.op_user_name = user["name"]
                    oplog.op_desc = 'ads_task_play_log excel导入 play_id:' + str(temp['play_id']) + " popularity:" + str(
                        temp['popularity']) \
                                    + " income:" + str(temp['income']) + " verify_result:" + str(temp['verify_result'])
                    co = {"play_id": temp['play_id'], "popularity": temp['popularity'], "income": temp['income'],
                          "verify_result": temp['verify_result']}
                    oplog.op_content = str(co)
                    oplog.createtime = datetime.datetime.now()
                    self.db_ads.add(oplog)

        try:
            self.db_ads.commit()
        except Exception as e:
            self.db_ads.rollback()
            log.e(e)
        finally:
            self.db_ads.close()


class PlayRecordExportHander(SwxJsonHandler):
    @tornado.web.authenticated
    def get(self, *args, **kwargs):

        sql = "SELECT k.task_create_time,t.task_id,n.anchor_level,t.user_id,k.plat_id,k.room_id," \
              "t.begin_time,t.postion_id,t.ads_id,t.popularity,k.estmate_income,t.play_id,t.income,t.verify_result,t.verify_status," \
              "t.record_path,t.screen_shot_path FROM ads_task_play_log t LEFT JOIN ads_task k" \
              " ON t.task_id = k.task_id LEFT JOIN ads_need_info n ON n.need_id = t.need_id WHERE 1=1"

        room_id = self.get_argument("room_id", None)
        user_id = self.get_argument("user_id", None)
        status = self.get_argument("status", None)
        verify_status = self.get_argument("verify_status", None)
        verify_result = self.get_argument("verify_result", None)
        begintime = self.get_argument("begin_time", None)

        filename = '_播放记录'
        if user_id is not None and user_id != "":
            sql = sql + " and t.user_id like '%" + user_id.strip() + "%'"
            # filename+="_用户id:"+str(user_id)
        if room_id is not None and room_id != "":
            sql = sql + " and k.room_id like '%" + room_id.strip() + "%'"
            filename += '_房间id:' + str(room_id)
        # if status is not None and status != "":
        #     sql = sql + " and t.status = '" + status.strip() + "'"
        #     filename += '_播放状态:' + status
        if verify_status is not None and verify_status != "":
            sql = sql + " and t.verify_status = '" + verify_status.strip() + "'"
            filename += '_审核状态' + verify_status

        if verify_result is not None and verify_result != "":
            filename += '_结果' + verify_result
            if (verify_result == '0' or verify_result == '-1'):
                sql = sql + " and t.verify_result = '" + verify_result.strip() + "'"
            else:
                sql = sql + " and t.verify_result != '0'"
                sql = sql + " and t.verify_result != '-1'"

        if begintime is not None and begintime != "":
            sql = sql + " and t.create_time = '" + begintime.strip() + "'"
            filename += '_任务创建时间' + begintime
        # else:
        #     sql = sql + " and t.create_time = '" + str(datetime.date.today()) + "'"

        if status is not None and status != "":
            if status == '3':
                sql = sql + " and (t.status = 1 or t.status=2)"
            else:
                sql = sql + " and t.status = '" + status.strip() + "'"

        offset = " ORDER BY t.play_id DESC"
        datas = self.db_ads.execute(sql + offset).fetchall()
        self.db_ads.close()
        roominfoMap = app_map().getRoomInfo()

        lst = list()
        for data in datas:
            task_create_time = data[0].isoformat().replace("T", " ") if data[0] is not None else ''
            task_id = data[1]
            anchor_level = data[2]
            user_id = data[3]
            plat_id = data[4]
            room_id = data[5]
            source_link = ''
            max_user_pre_count = ''
            new_level = ''
            if room_id in roominfoMap:
                roominfo = roominfoMap[room_id]
                source_link = roominfo["source_link"]
                max_user_pre_count = roominfo["max_user_pre_count"]
                new_level = roominfo["new_level"]
            begin_time = data[6].isoformat().replace("T", " ") if data[6] is not None else ''
            postion_id = data[7]
            ads_id = data[8]
            popularity = data[9]
            estmate_income = str(data[10].quantize(Decimal('0.00'))) if data[10] is not None else ""
            play_id = data[11]
            income = str(data[12].quantize(Decimal('0.00'))) if data[12] is not None else ""
            verify_result = data[13]
            verify_status = data[14]
            record_path = data[15] if data[15] is not None else ''
            screen_shot_path = ''
            if data[16] is not None and data[16]!='':
                strlist = list()
                arr = data[16].split(',')
                for i in arr:
                    (filepath, tempfilename) = os.path.split(i)
                    strlist.append(filepath)
                screen_shot_path=','.join(strlist)

            lst.append({"task_create_time": task_create_time, "task_id": task_id, "anchor_level": anchor_level,
                        'new_level': new_level,
                        "user_id": user_id, "plat_id": plat_id, "room_id": room_id, "source_link": source_link,
                        'begin_time': begin_time,
                        "postion_id": postion_id, "ads_id": ads_id, 'max_user_pre_count': max_user_pre_count,
                        "popularity": popularity,
                        "estmate_income": estmate_income, 'play_id': play_id, 'income': income,
                        'verify_result': verify_result, "verify_status": verify_status,
                        'record_path': record_path, 'screen_shot_path': screen_shot_path
                        })

        list_name = ['任务日期', '任务id', '任务级别', '主播级别', '用户id', 'plat_id', 'room_id',
                     'source_link', '播放时间', '播放版位', '播放素材id', '30天平均最高人气', '实时人气', '任务预计收入',
                     '播放id', '播放收入（运营审核修改项）', '识别结果0为成功其他为失败（运营审核修改项）', '视频审核结果(0:未审核,1:已审核)',
                     '视频地址', '截图目录']
        els_url = exportPlayRecord(lst, list_name, filename)
        self.write_json(0, data=els_url)
        return


class playLogImportSelectHander(SwxJsonHandler):
    @tornado.web.authenticated
    def get(self):
        playnum = self.get_argument("playnum", None)
        if playnum is None:
            self.write_json(-1, 'playlog进度序列号不能为空')
            return
        if int(playnum) not in app_playlog:
            app_playlog[int(playnum)] = {"now": 0, "max": 0}
        self.write_json(0, '', app_playlog[int(playnum)])


class playLogImportCreateHander(SwxJsonHandler):
    @tornado.web.authenticated
    def get(self, *args, **kwargs):
        date_now = int(time.time())
        app_playlog[date_now] = {"now": 0, "max": 0}
        self.write_json(0, '', date_now)


####---------------任务查询---------------------------------
class TaskSelectListHander(SwxJsonHandler):
    @tornado.web.authenticated
    def get(self, *args, **kwargs):



        self.render("/ads_manager/task_select_info/task_select_list.mako")

    @tornado.web.authenticated
    def post(self, *args, **kwargs):
        limit, args = self.get_pages_args()
        #
        filter = args["filter"]
        level = ''
        schedule_id = ''
        task_result = ''
        task_status = ''

        date = ''
        user_id = ''
        plat_id = ''
        room_id = ''
        if "level" in filter.keys():
            level = filter["level"]
            schedule_id = filter["schedule_id"]
            task_result = filter["task_result"]
            task_status = filter["task_status"]
            date = filter["date"]
            user_id = filter["user_id"]
            # plat_id = filter["platform_id"]
            room_id = filter["room_id"]
        query = self.db_entourage.query(AdsTask, func.count(TaskPlayLog.play_id),
                                        func.sum(case([(TaskPlayLog.status == 2, 1)],
                                                      else_=0)), NeedGroupInfo.anchor_level).join(TaskPlayLog,
                                                                                                  AdsTask.task_id == TaskPlayLog.task_id).join(
            NeedGroupInfo, NeedGroupInfo.ads_need_group_id == AdsTask.group_id).group_by(
            AdsTask)
        # data_now = datetime.datetime.now().strftime('%Y-%m-%d')

        if schedule_id:
            query = query.filter(AdsTask.schedule_id == schedule_id)
        if task_result:
            if task_result == '-1':
                query = query.filter(
                    or_(AdsTask.task_result == task_result, and_(AdsTask.task_status != 1, AdsTask.task_status != 5)))
            else:
                query = query.filter(
                    and_(AdsTask.task_result == task_result, or_(AdsTask.task_status == 1, AdsTask.task_status == 5)))

        if task_status:
            if task_status == '0':
                query = query.filter(and_(AdsTask.task_status != 1, AdsTask.task_status != 5))
            elif task_status == '15':
                query = query.filter(or_(AdsTask.task_status == 1, AdsTask.task_status == 5))
            else:
                query = query.filter(AdsTask.task_status == task_status)
        if date:
            query = query.filter(AdsTask.create_time == date)
        # else:
        #     query = query.filter(AdsTask.create_time == data_now)
        if user_id:
            query = query.filter(AdsTask.user_id == user_id)
        if level:
            query = query.filter(NeedGroupInfo.anchor_level == level)
        if room_id:
            query = query.filter(AdsTask.room_id == room_id)
        # if plat_id == '' and room_id:
        #     query = query.filter(AdsTask.room_id == room_id)

        query = query.order_by(AdsTask.task_id.desc())
        total = query.count()
        query = query.limit(int(limit['per_page'])).offset(
            (int(limit['page_index'] * 10)))
        query_result = query.all()
        lst = list()
        for item in query_result:
            lst.append({
                'task_id': item[0].task_id or 0,
                'user_id': item[0].user_id or 0,
                'plat_id': item[0].plat_id or 0,
                'room_id': item[0].room_id or '',
                'task_result': item[0].task_result or 0,
                'task_status': item[0].task_status or 0,
                'schedule_id': item[0].schedule_id or 0,
                'estmate_income': str(item[0].estmate_income) or '',
                'task_create_time': item[0].task_create_time.isoformat() or '',
                'create_time': str(item[0].create_time) or '',
                'task_play_log': str(item[1]) or '',
                'task_play_log_end': str(item[2]) or '',
                'anchor_level': str(item[3]) or '',
            })
        ret = dict()
        ret['page_index'] = limit['page_index']
        ret['total'] = total
        ret['data'] = lst
        for info_data in ret['data']:
            if info_data['task_result'] == 0:
                info_data['task_name'] = '完成'
            elif info_data['task_result'] == 1:
                info_data['task_name'] = '放弃'
            elif info_data['task_result'] == -1:
                info_data['task_name'] = '未知'

            info_data['play_log'] = str(info_data['task_play_log_end']) + '/' + str(info_data['task_play_log'])

            if info_data['task_status'] != 1 and info_data['task_status'] != 5:
                info_data['task_status_name'] = '未开始'
                info_data['task_name'] = '未知'
            elif info_data['task_status'] == 1:
                info_data['task_status_name'] = '正在进行'
            elif info_data['task_status'] == 5:
                info_data['task_status_name'] = '已结束'
        # for item in app_map().TLogWithdrawAnchor():
        self.write_json(0, data=ret)
        self.db_entourage.close()


class SeleteTaskplaylogList(SwxJsonHandler):
    def get(self, *args, **kwargs):
        task_id = self.get_argument("task_id", None)
        #
        try:
            lst = []
            query_schedule = ''
            query = ''
            verify_status_name = ''
            verify_result_name = ''
            status_name = ''
            if task_id:
                query = self.db_entourage.query(TaskPlayLog).filter(
                    TaskPlayLog.task_id == task_id).order_by(TaskPlayLog.play_id.desc())

                query_schedule = query.all()
                # sql_session.update({AdsConfigAnchorWhitelist.eff_airtime: time_len})
                if query_schedule:
                    for ptype in query_schedule:

                        if ptype.verify_status == 0:
                            verify_status_name = '未审核'
                        elif ptype.verify_status == 1:
                            verify_status_name = '已审核'

                        if ptype.verify_result == -1:
                            verify_result_name = '初始状态'
                        elif ptype.verify_result == 0:
                            verify_result_name = '成功'
                        elif ptype.verify_result == 1:
                            verify_result_name = '没有找到截图'
                        else:
                            verify_result_name = '失败'

                        if ptype.status == 0:
                            status_name = '未播放'
                        elif ptype.status == 1:
                            status_name = '开始播放'
                        elif ptype.status == 2:
                            status_name = '结束播放'

                        lst.append({
                            'play_id': ptype.play_id or '',
                            'user_id': ptype.user_id or 0,
                            'status': status_name,
                            'income': float(ptype.income),
                            'popularity': ptype.popularity or 0,
                            'screen_shot_path': str(ptype.screen_shot_path) or '',
                            'record_path': str(ptype.record_path) or '',
                            'verify_status': verify_status_name,
                            'verify_result': verify_result_name,
                            'log_create_time': ptype.log_create_time.isoformat() or '',
                        })
                    self.write_json(0, '', lst)
                    self.db_entourage.close()
                else:
                    self.write_json(-1, '没有对应的task_play_log', lst)
                    # self.write_json(0, data=ret)
                    self.db_entourage.close()
        except Exception as e:
            self.db_entourage.rollback()
            log.e(e)
            self.write_json(500, "获取错误")
        finally:
            self.db_entourage.close()

        self.db_entourage.close()


class SeleteTaskPlatList(SwxJsonHandler):
    def get(self, *args, **kwargs):

        try:
            lst = []
            query = self.db_guild.query(BasePlatformsGuild.id, BasePlatformsGuild.name).order_by(
                BasePlatformsGuild.id)
            query_schedule = query.all()
            # sql_session.update({AdsConfigAnchorWhitelist.eff_airtime: time_len})
            for ptype in query_schedule:
                lst.append(json.loads(json.dumps(ptype, cls=AlchemyEncoder)))
            self.write_raw_json(lst)
            self.db_entourage.close()
        except Exception as e:
            self.db_entourage.rollback()
            log.e(e)
            self.write_json(500, "获取错误")
        finally:
            self.db_entourage.close()

        self.db_entourage.close()


####---------------提现用户详情---------------------------------
class IdentityPersonalListHander(SwxJsonHandler):
    @tornado.web.authenticated
    def get(self, *args, **kwargs):
        self.render("/ads_manager/identity_personal_info/identity_personal_list.mako")

    @tornado.web.authenticated
    def post(self, *args, **kwargs):
        limit, args = self.get_pages_args()
        filter = args["filter"]

        id_user_name = ''
        hold_user_name = ''
        bank_name = ''
        verify_status = ''
        identity_status = ''
        date = ''
        if "date" in filter.keys():
            id_user_name = filter["id_user_name"]
            hold_user_name = filter["hold_user_name"]
            bank_name = filter["bank_name"]
            verify_status = filter["verify_status"]
            identity_status = filter["identity_status"]
            date = filter["date"]

        query = self.db_wealth.query(TIdentityPersonal)
        # data_now = datetime.datetime.now().strftime('%Y-%m-%d')

        if date:
            query = query.filter(func.date_format(TIdentityPersonal.logtime, '%Y-%m-%d') == date)

        if id_user_name:
            id_user_name = '%' + id_user_name + '%'
            query = query.filter(TIdentityPersonal.id_user_name.like(id_user_name))
        if hold_user_name:
            hold_user_name = '%' + hold_user_name + '%'
            query = query.filter(TIdentityPersonal.hold_user_name.like(hold_user_name))
        if bank_name:
            bank_name = '%' + bank_name + '%'
            query = query.filter(TIdentityPersonal.bank_name.like(bank_name))
        if verify_status:
            if verify_status == '1':
                query = query.filter(TIdentityPersonal.verify_status == 1)
            elif verify_status == '2':
                query = query.filter(TIdentityPersonal.verify_status != 1)

        if identity_status:
            if identity_status == '1':
                query = query.filter(TIdentityPersonal.status == 1)
            elif identity_status == '0':
                query = query.filter(TIdentityPersonal.status == 0)

        query = query.order_by(TIdentityPersonal.identity_id.desc())
        total = query.count()
        query = query.limit(int(limit['per_page'])).offset(
            (int(limit['page_index'] * 10)))
        query_result = query.all()
        lst = list()

        for item in query_result:
            lst.append({
                'identity_id': item.identity_id or 0,
                'user_id': item.user_id or 0,
                'verify_status': item.verify_status or '',
                'status': item.status or '',
                'id_user_name': item.id_user_name or '',
                'id_number': item.id_number or '',
                'bank_name': item.bank_name or '',
                'bank_card_number': item.bank_card_number or '',
                'hold_user_name': item.hold_user_name or '',
                'bank_sub_name': str(item.bank_sub_name) or '',
                'id_img_front': item.id_img_front or '',
                'qq_number': item.qq_number or '',
                'id_img_back': item.id_img_back or '',
                'logtime': item.logtime.isoformat() or '',
            })

        ret = dict()
        ret['page_index'] = limit['page_index']
        ret['total'] = total
        ret['data'] = lst
        for info_data in ret['data']:
            if info_data['verify_status'] == 1:
                info_data['verify_status_name'] = '已审核'
            else:
                info_data['verify_status_name'] = '未审核'

            if info_data['status'] == 1:
                info_data['status_name'] = '正常'
            elif info_data['status'] == 2:
                info_data['status_name'] = '删除'

        self.write_json(0, data=ret)
        self.db_wealth.close()


class PlayLogAutoListHander(SwxJsonHandler):
    @tornado.web.authenticated
    def get(self, *args, **kwargs):
        self.render("/ads_manager/autoreview/autoreview.mako")

    @tornado.web.authenticated
    def post(self, *args, **kwargs):
        limit, args = self.get_pages_args()

        filter = args["filter"]
        search = filter["search"]
        today = datetime.date.today()
        towday = datetime.timedelta(days=2)
        oneday = datetime.timedelta(days=1)
        yestorday = today - oneday

        num = self.db_ads.query(PlayLogAuto).filter(PlayLogAuto.auto_date == yestorday).count()
        if num <= 0:
            max = self.db_ads.query(TaskPlayLog).filter(and_(TaskPlayLog.create_time == yestorday)).count()
            now = self.db_ads.query(TaskPlayLog).filter(
                and_(TaskPlayLog.create_time == yestorday, TaskPlayLog.verify_status == 1)).count()
            pa = PlayLogAuto()
            pa.auto_max = max
            pa.auto_now = now
            pa.auto_date = yestorday
            pa.auto_status = 0
            self.db_ads.add(pa)
            try:
                self.db_ads.commit()
            except Exception as e:
                self.db_ads.rollback()
                log.e(e)
            finally:
                self.db_ads.close()

        query = self.db_ads.query(PlayLogAuto)
        if search is not None and search != '':
            query = query.filter(PlayLogAuto.auto_date == search)
        total = query.count()
        query = query.order_by(PlayLogAuto.auto_date.desc())
        query = query.limit(int(limit['per_page'])).offset(
            (int(limit['page_index'] * 10)))
        query_result = query.all()

        lst = list()
        for item in query_result:
            lst.append(json.loads(json.dumps(item, cls=AlchemyEncoder)))
        ret = dict()
        ret['page_index'] = limit['page_index']
        ret['total'] = total
        ret['data'] = lst
        self.write_json(0, data=ret)
        self.db_ads.close()


class PlayLogAutoAuditHander(SwxJsonHandler):
    @tornado.web.authenticated
    @tornado.gen.coroutine
    def post(self, *args, **kwargs):

        date = self.get_argument("date")
        id = self.get_argument("id")
        playnum = self.get_argument("playnum")

        if not date:
            self.write_json(-1, "日期不能为空")
            return
        # start=str(date)+" 00:00:00"
        # end=str(date)+" 23:59:59"

        results = self.db_ads.query(TaskPlayLog).filter(
            and_(TaskPlayLog.create_time == date, TaskPlayLog.verify_status == 0)).all()
        yield self.autoAudit(id, results, date, playnum)
        self.write_json(0)

    @run_on_executor
    def autoAudit(self, id, results, date, playnum):
        try:
            for ret in results:
                p_data = self.db_ads.query(TaskPlayLog).filter(TaskPlayLog.play_id == ret.play_id).first()
                now = app_playlogAuto[int(playnum)]["now"] + 1
                max = app_playlogAuto[int(playnum)]["max"]
                app_playlogAuto[int(playnum)] = {"now": now, "max": max}

                ad_results = self.db_detect.query(Adresult).filter(Adresult.ad_key == ret.play_id).all()
                temp_result=''
                if ad_results:
                    # 更新自动化审核进度
                    res_list=list()
                    for ad in ad_results:
                        res_list.append(ad.is_ad)
                    p_data.verify_status = 1
                    p_data.verify_result=0 if 1 in res_list else -3
                    temp_result=0 if 1 in  res_list else -3


                else:
                    p_data.verify_status = 1
                    p_data.verify_result = -2
                    temp_result=-2

                oplog = AdsOpLog()
                oplog.op_type = 6
                user = self.get_current_user()
                oplog.op_user_id = user["id"]
                oplog.op_user_name = user["name"]
                oplog.op_desc = '自动化审核ads_task_play_Log play_id:' + str(ret.play_id)
                oc = {"play_id": ret.play_id,'verify_result':temp_result}
                oplog.op_content = str(oc)
                oplog.createtime = datetime.datetime.now()
                self.db_ads.add(oplog)
                self.db_ads.commit()
        except Exception as e:
            self.write_json(-1, '自动化审核失败')
            self.db_ads.rollback()
            self.db_ads.close()
            log.e(e)
            return

        try:
            # self.db_ads.commit()
            v_data = self.db_ads.query(PlayLogAuto).filter(PlayLogAuto.auto_id == id).first()
            now = self.db_ads.query(TaskPlayLog).filter(
                and_(TaskPlayLog.create_time == date,
                     TaskPlayLog.verify_status == 1)).count()

            v_data.auto_status = 1
            v_data.auto_now = now
            self.db_ads.commit()
        except Exception as e:
            self.write_json(-1, '自动化审核失败')
            self.db_ads.rollback()
            log.e(e)
            return
        finally:
            self.db_ads.close()
            self.db_detect.close()


class playLogAutoSelectHander(SwxJsonHandler):
    @tornado.web.authenticated
    def get(self):
        playnum = self.get_argument("playnum", None)
        if playnum is None:
            self.write_json(-1, 'playlog进度序列号不能为空')
            return
        if int(playnum) not in app_playlogAuto:
            app_playlogAuto[int(playnum)] = {"now": 0, "max": 0}
        self.write_json(0, '', app_playlogAuto[int(playnum)])


class playLogAutoCreateHander(SwxJsonHandler):
    @tornado.web.authenticated
    def get(self, *args, **kwargs):
        date_now = int(time.time())
        id = self.get_argument('id')
        ret = self.db_ads.query(PlayLogAuto).filter(PlayLogAuto.auto_id == id).first()
        if ret:
            app_playlogAuto[date_now] = {"now": ret.auto_now, "max": ret.auto_max}
            self.write_json(0, '', date_now)
        else:
            self.write_json(-1, '没有找到对应的数据信息')


class ImgDemo(SwxJsonHandler):
    @tornado.web.authenticated
    def get(self, *args, **kwargs):
        self.render("/ads_manager/img_demo/img_demo.mako")

    @tornado.web.authenticated
    def post(self, *args, **kwargs):
        limit, args = self.get_pages_args()
        ret = dict()
        self.write_json(0, data=ret)
        self.db_ads.close()
